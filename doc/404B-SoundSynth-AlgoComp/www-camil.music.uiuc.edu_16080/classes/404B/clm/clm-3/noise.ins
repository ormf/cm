;;; -*- syntax: common-lisp; base: 10; mode: lisp -*-
;;;
;;; The "noise" instrument (useful for Oceanic Music):

(defun attack-point (duration attack decay &optional (total-x 100.0))
  (* total-x (/ (if (= 0.0 attack)
		    (if (= 0.0 decay)
			(/ duration 4)
		      (/ (- duration decay) 4))
		  attack)
		duration)))

(definstrument fm-noise (startime dur freq0 amp ampfun ampat ampdc
			 freq1 glissfun freqat freqdc rfreq0 rfreq1 rfreqfun rfreqat rfreqdc
			 dev0 dev1 devfun devat devdc
			 &key (degree 0.0)
			      (distance 1.0)
			      (reverb-amount 0.005))
  
  ;; ampat = amp envelope attack time, and so on -- this instrument assumes your envelopes go
  ;; from 0 to 100 on the x-axis, and that the "attack" portion ends at 25, the "decay" portion
  ;; starts at 75.  "rfreq" is the frequency of the random number generator -- if below about
  ;; 25 hz you get automatic composition, above that you start to get noise.  well, you get
  ;; a different kind of noise.  "dev" is the bandwidth of the noise -- very narrow gives a 
  ;; whistle, very broad more of a whoosh.  this is basically "simple fm", but the modulating
  ;; signal is white noise.
  
  (let* ((beg (floor (* startime *srate*)))
	 (end (+ beg (floor (* dur *srate*))))
	 (carrier (make-oscil :frequency freq0))
	 (modulator (make-rand :frequency rfreq0 :amplitude 1.0))
	 (loc (make-locsig :degree degree :distance distance :reverb reverb-amount))
	 (dev-0 (hz->radians dev0))
	 
	 ;; next fix-up troubles in attack and decay times (there are lots of ways to handle this --
	 ;; the basic problem is that these durned instruments end up having way too many parameters.
	 ;; rick taube's common music replacement for pla should help, but just for old time's sake,
	 ;; we'll do it the way the ancients did it.  (we could also package up this stuff in our
	 ;; own function, somewhat like the allvln function in vln.clm, leaving the instrument code
	 ;; to apply envelopes and other data to some patch).
	 
	 (amp-attack (attack-point dur ampat ampdc))
	 (amp-decay (- 100.0 (attack-point dur ampdc ampat)))
	 (freq-attack (attack-point dur freqat freqdc))
	 (freq-decay (- 100.0 (attack-point dur freqdc freqat)))
	 (dev-attack (attack-point dur devat devdc))
	 (dev-decay (- 100.0 (attack-point dur devdc devat)))
	 (rfreq-attack (attack-point dur rfreqat rfreqdc))
	 (rfreq-decay (- 100.0 (attack-point dur rfreqdc rfreqat)))
	 
	 ;; now make the actual envelopes -- these all assume we are thinking in terms of
	 ;; the "value when the envelope is 1" (i.e. dev1 and friends), and the "value when
	 ;; the envelope is 0" (i.e. dev0 and friends) -- over the years this seemed to make
	 ;; beginners happier than various other ways of describing the y-axis behaviour of
	 ;; the envelope.  all this boiler-plate for envelopes might seem overly elaborate
	 ;; when our basic instrument is really simple, but in most cases, and this one in
	 ;; particular, nearly all the musical interest comes from the envelopes, not the
	 ;; somewhat dull spectrum generated by the basic patch.
	 
	 (dev-f (make-env :envelope (stretch-envelope devfun 25 dev-attack 75 dev-decay)  :duration dur
			   :scaler (hz->radians (- dev1 dev0))))
	 (amp-f (make-env :envelope (stretch-envelope ampfun 25 amp-attack 75 amp-decay) :duration dur
			   :scaler amp))
	 (freq-f (make-env :envelope (stretch-envelope glissfun 25 freq-attack 75 freq-decay) :duration dur
			    :scaler (hz->radians (- freq1 freq0))))
	 (rfreq-f (make-env :envelope (stretch-envelope rfreqfun 25 rfreq-attack 75 rfreq-decay) :duration dur
			     :scaler (hz->radians (- rfreq1 rfreq0)))))
    (run
     (loop for i from beg to end do
       (locsig loc i (* (env amp-f)
			(oscil carrier (+ (env freq-f)
					  (* (+ dev-0 (env dev-f)) 
					     (rand modulator (env rfreq-f)))))))))))

; (fm-noise 0 2.0 500 .25 '(0 0 25 1 75 1 100 0) .1 .1 1000 '(0 0 100 1) .1 .1 10 1000 '(0 0 100 1) 0 0 100 500 '(0 0 100 1) 0 0)
