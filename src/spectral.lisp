;;; **********************************************************************
;;; Copyright (C) 2009 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from spectral.scm on 04-Aug-2009 14:11:45

(in-package :cm)

(defun harmonics (h1 h2 &key ((:hertz hz) 1) invert undertones
                  ((:keynum knum) nil) ((:rescale scaler) nil)
                  scale-order harmonic)
  (unless (< h1 h2) (error "harmonics: ~s not less than ~s." h1 h2))
  (when harmonic
    (unless (<= h1 harmonic h2)
      (error "harmonics: :harmonic ~s not between ~s and ~s."
             harmonic
             h1
             h2)))
  (let* ((freq (if knum (hertz knum) hz))
         (spec
          (if invert
              (if undertones
                  (if harmonic
                      (/ freq (/ h2 harmonic))
                      (loop for h from h2 downto h1
                            collect (/ freq (/ h2 h))))
                      (if harmonic
                          (* freq (/ h2 harmonic))
                          (loop for h from h2 downto h1
                                collect (* freq (/ h2 h)))))
                      (if undertones
                          (if harmonic
                              (/ freq (/ harmonic h1))
                              (loop for h from h1 to h2
                               collect (/ freq (/ h h1))))
                              (if
                               harmonic
                               (* freq (/ harmonic h1))
                               (loop for h from h1 to h2
                                collect (* freq (/ h h1))))))))
                  (when scaler
                    (if knum (setf scaler (hertz scaler :hz t)))
                    (do ((root (car spec))
                         (term (elt spec (- h2 h1)))
                         (tail (cdr spec) (cdr tail)))
                        ((null tail) nil)
                      (rplaca tail
                              (rescale
                               (car tail)
                               root
                               term
                               root
                               scaler))))
                  (when scale-order
                    (when harmonic
                      (error "harmonics: :scale-order and :harmonic are exclusive."))
                    (case scale-order
                      ((:reverse reverse)
                       (setf spec (nreverse spec)))
                      ((:up up)
                       (if undertones (setf spec (nreverse spec))))
                      ((:down down)
                       (if (not undertones)
                           (setf spec (nreverse spec))))
                      ((:random random) (setf spec (shuffle spec)))
                      (t
                       (error "harmonics: not a :scale-order value: ~S"
                              scale-order))))
                  (if knum (keynum spec :hz t) spec)))

(defun rm-spectrum (set1 set2 &key (spectrum nil) (minimum nil)
                    (maximum nil) (hz nil) (scale-order :up)
                    (remove-duplicates nil))
  (flet ((sums-and-diffs (f1 f2)
           (if (= f1 f2) (list) (list (abs (- f1 f2)) (+ f1 f2)))))
    (let* ((type
            (cond ((not spectrum)
                   (if hz
                       ':hertz
                       (if (consp set1)
                           (if (let
                                ((t10 (car set1)))
                                (and t10 (symbolp t10)))
                               ':note
                               ':keynum)
                           (if (and set1 (symbolp set1))
                               ':note
                               ':keynum))))
                  ((member spectrum '(:note :keynum :hertz))
                   spectrum)
                  (t
                   (error "Spectrum ~S not one of: :note :keynum :hertz."
                          spectrum))))
           (spec
            (if (consp set1)
                (if (consp set2)
                    (loop with l2 = (hertz set2 :hz hz)
                          for f1 in (hertz set1 :hz hz)
                          append (loop for f2 in l2
                                  append (sums-and-diffs f1 f2)))
                                 (loop with f2 = (hertz set2 :hz hz)
                                  for f1 in (hertz set1 :hz hz)
                                  append (sums-and-diffs f1 f2)))
                                 (if
                                  (consp set2)
                                  (loop with f1 = (hertz set1 :hz hz)
                                   for f2 in (hertz set2 :hz hz)
                                   append (sums-and-diffs f1 f2))
                                   (sums-and-diffs
                                    (hertz set1 :hz hz)
                                    (hertz set2 :hz hz))))))
                    (when minimum
                      (do ((freq
                            (hertz minimum :hz (eq type ':hertz)))
                           (tail spec (cdr tail)))
                          ((null tail) nil)
                        (do ()
                            ((not (< (car tail) freq)))
                          (rplaca tail (* (car tail) 2)))))
                    (when maximum
                      (do ((freq
                            (hertz maximum :hz (eq type ':hertz)))
                           (tail spec (cdr tail)))
                          ((null tail) nil)
                        (do ()
                            ((not (> (car tail) freq)))
                          (rplaca tail (/ (car tail) 2)))))
                    (cond ((eq scale-order ':up)
                           (setf spec (sort spec #'<)))
                          ((eq scale-order ':down)
                           (setf spec (sort spec #'>)))
                          ((eq scale-order ':random)
                           (setf spec (shuffle spec))))
                    (cond ((eq type ':note)
                           (setf spec (note spec :hz t)))
                          ((eq type ':keynum)
                           (setf spec (keynum spec :hz t)))
                          ((eq type ':hertz) nil))
                    (if (and remove-duplicates
                             (do
                              ((tail spec (cdr tail)) (flag nil))
                              ((or (null tail) flag) flag)
                              (setf
                               flag
                               (member (car tail) (cdr tail)))))
                        (do ((tail spec (cdr tail))
                             (resl (list nil)))
                            ((null tail) (cdr resl))
                          (if (member (car tail) resl)
                              nil
                              (setf
                               resl
                               (nconc resl (list (car tail))))))
                        spec))))

(defun fm-spectrum (carrier mratio index &key (spectrum nil)
                    (minimum nil) (maximum nil) invert
                    (ignore-zero nil izp)
                    (amplitudes (eq spectrum ':raw)) all-sidebands
                    scale-order (remove-duplicates t))
  (let ((data nil) (type nil) (bot nil) (top nil))
    (case spectrum
      ((nil) (setf type spectrum))
      ((:hertz) (setf type spectrum)
       (unless izp (setf ignore-zero t)))
      ((:keynum) (setf type spectrum)
       (unless izp (setf ignore-zero t)))
      ((:note) (setf type spectrum)
       (unless izp (setf ignore-zero t)))
      (t
       (error "Spectrum ~s not one of: false :note :keynum :hertz."
              spectrum)))
    (when spectrum
      (if minimum (setf bot (hertz minimum :hz (eq type ':hertz))))
      (if maximum (setf top (hertz maximum :hz (eq type ':hertz)))))
    (setf data
          (fm-spectrum1 carrier mratio index (eq type nil) nil
           all-sidebands))
    (when ignore-zero
      (setf data (delete-if (lambda (x) (zerop (car x))) data)))
    (when invert
      (dolist (s data)
        (let ((f (first s)))
          (unless (= f 0.0)
            (rplaca s (abs (hz-invert (hz-ify carrier) f))))))
      (setf data (sort data (lambda (x y) (< (first x) (first y))))))
    (when (or (eq type ':note) (eq type ':keynum))
      (if (or top bot)
          (let ((f nil) (k nil) (e nil) (l (list)))
            (dolist (s data)
              (setf f (abs (first s)))
              (when (not (= f 0.0))
                (do () ((<= f top) nil)  (setf f (* f 0.5)))
                (do () ((>= f bot) nil)  (setf f (* f 2.0))))
              (setf k
                    (if (= f 0.0)
                        'r
                        (if (eq type ':keynum)
                            (keynum f :hz t)
                            (note f :hz t))))
              (setf e (find-if (lambda (x) (equal k (car x))) l))
              (if (and e remove-duplicates)
                  (rplaca (cdr e) (+ (cadr e) (second s)))
                  (progn (rplaca s k) (push s l))))
            (setf data (nreverse l)))
          (do ((low (hertz 0)) (tail data (cdr tail)))
              ((null tail) nil)
            (unless (< (caar tail) low)
              (setf (caar tail)
                    (if (eq type ':note)
                        (note (caar tail) :hz t)
                        (keynum (caar tail) :hz t)))))))
    (unless (eq type nil)
      (setf data
            (cond ((not scale-order)
                   (if (or top bot)
                       (sort data
                             (lambda
                              (a b)
                              (scale< (first a) (first b))))
                       data))
                  ((eq scale-order :up)
                   (sort data
                         (lambda (a b)
                           (scale< (first a) (first b)))))
                  ((eq scale-order :down)
                   (sort data
                         (lambda (a b)
                           (scale> (first a) (first b)))))
                  ((eq scale-order :random) (shuffle data))
                  (t
                   (error "Not a valid :scale-order: ~s."
                          scale-order)))))
    (cond ((not amplitudes)
           (do ((tail data (cdr tail)))
               ((null tail) nil)
             (rplaca tail (car (car tail)))))
          ((eq amplitudes :normalized)
           (dolist (s data) (rplaca (cdr s) (abs (second s)))))
          ((eq amplitudes :weights)
           (dolist (s data)
             (rplaca (cdr s) (abs (second s)))
             (rplacd s (cons ':weight (cdr s)))))
          ((eq amplitudes t) nil)
          (t (error "Not an amplitude value: ~s." amplitudes)))
    data))

(defun sidebands-to-cm (low high lb ub)
  (let* ((m (/ (- high low) (- ub lb))) (c (- high (* ub m))))
    (values c m (/ m c))))

(defun bes-jn (unn ux)
  (let ((nn unn) (x ux))
    (let* ((n (floor (abs nn)))
           (besn
            (if (= n 0)
                (bes-j0 x)
                (if (= n 1)
                    (bes-j1 x)
                    (if (zerop x)
                        0.0
                        (let ((iacc 40)
                              (ans 0.0)
                              (bigno 1.0E+10)
                              (bigni 1.0E-10))
                          (if (> (abs x) n)
                              (do
                               ((tox (/ 2.0 (abs x)))
                                (bjm (bes-j0 (abs x)))
                                (bj (bes-j1 (abs x)))
                                (j 1 (+ j 1))
                                (bjp 0.0))
                               ((= j n) (setf ans bj))
                               (setf bjp (- (* j tox bj) bjm))
                               (setf bjm bj)
                               (setf bj bjp))
                              (let
                               ((tox (/ 2.0 (abs x)))
                                (m
                                 (*
                                  2
                                  (floor
                                   (/ (+ n (sqrt (* iacc n))) 2))))
                                (jsum 0.0)
                                (bjm 0.0)
                                (sum 0.0)
                                (bjp 0.0)
                                (bj 1.0))
                               (do
                                ((j m (- j 1)))
                                ((= j 0))
                                (setf bjm (- (* j tox bj) bjp))
                                (setf bjp bj)
                                (setf bj bjm)
                                (when
                                 (> (abs bj) bigno)
                                 (setf bj (* bj bigni))
                                 (setf bjp (* bjp bigni))
                                 (setf ans (* ans bigni))
                                 (setf sum (* sum bigni)))
                                (if (not (= 0 jsum)) (incf sum bj))
                                (setf jsum (- 1 jsum))
                                (if (= j n) (setf ans bjp)))
                               (setf sum (- (* 2.0 sum) bj))
                               (setf ans (/ ans sum))))
                          (if (and (minusp x) (oddp n))
                              (- ans)
                              ans)))))))
      (if (and (minusp nn) (oddp nn)) (- besn) besn))))

(defun fm-spectrum1 (carrier mratio index neg-freq? pos-amp?
                     sideband-scaler)
  (setf carrier (hz-ify carrier))
  (let ((mfreq (* carrier mratio))
        (nsides
         (if sideband-scaler
             (round (* sideband-scaler index))
             (+ (round index) 1)))
        (spectrum '()))
    (setf spectrum
          (loop for k from (- nsides) to nsides
                for a = (bes-jn k index)
                unless (= a 0.0)
                  collect (list (+ carrier (* mfreq k)) a)))
                (unless neg-freq?
                  (do ((neg nil) (pos nil))
                      ((not (minusp (caar spectrum))) nil)
                    (setf neg (pop spectrum))
                    (setf pos (abs (first neg)))
                    (rplaca neg pos)
                    (rplaca (cdr neg) (- (second neg)))
                    (let ((side (assoc (first neg) spectrum)))
                      (if side
                          (rplaca (cdr side)
                                  (+ (cadr side) (second neg)))
                          (let ((p
                                 (do
                                  ((i
                                    (- (length spectrum) 1)
                                    (- i 1))
                                   (f nil)
                                   (x nil))
                                  ((or f (< i 0)) f)
                                  (setf x (car (elt spectrum i)))
                                  (if (< x pos) (setf f i)))))
                            (if (not p)
                                (push neg spectrum)
                                (let
                                 ((tail (nthcdr p spectrum)))
                                 (setf neg (list neg))
                                 (rplacd neg (cdr tail))
                                 (rplacd tail neg))))))))
                (when pos-amp?
                  (dolist (s spectrum)
                    (rplaca (cdr s) (abs (second s)))))
                spectrum))

(defun hz-ify (x) (if (and x (symbolp x)) (hertz x) (* x 1.0)))

(defun hz-invert (f1 f2)
  (let ((l1 (log f1)) (l2 (log f2))) (exp (+ l1 (- l1 l2)))))

(defun bes-j0 (x)
  (if (< (abs x) 8.0)
      (let* ((y (* x x))
             (ans1
              (+ 5.756849E+10
                 (* y
                    (+ -1.3362591E+10
                       (* y
                          (+ 6.5161965E+8
                             (*
                              y
                              (+
                               -1.1214424E+7
                               (*
                                y
                                (+
                                 77392.33
                                 (* y -184.90524)))))))))))
             (ans2
              (+ 5.756849E+10
                 (* y
                    (+ 1.029533E+9
                       (* y
                          (+ 9494681.0
                             (*
                              y
                              (+
                               59272.65
                               (* y (+ 267.85327 y)))))))))))
        (/ ans1 ans2))
      (let* ((ax (abs x))
             (z (/ 8.0 ax))
             (y (* z z))
             (xx (- ax 0.7853982))
             (ans1
              (+ 1.0
                 (* y
                    (+ -0.0010986286
                       (* y
                          (+ 2.7345104E-5
                             (*
                              y
                              (+
                               -2.0733708E-6
                               (* y 2.0938872E-7)))))))))
             (ans2
              (+ -0.015625
                 (* y
                    (+ 1.4304888E-4
                       (* y
                          (+ -6.9111475E-6
                             (*
                              y
                              (+
                               7.621095E-7
                               (* y -9.349451E-8))))))))))
        (* (sqrt (/ 0.63661975 ax))
           (- (* (cos xx) ans1) (* z (sin xx) ans2))))))

(defun bes-j1 (x)
  (if (< (abs x) 8.0)
      (let* ((y (* x x))
             (ans1
              (* x
                 (+ 7.2362615E+10
                    (* y
                       (+ -7.8950595E+9
                          (* y
                             (+
                              2.4239685E+8
                              (*
                               y
                               (+
                                -2972611.5
                                (*
                                 y
                                 (+
                                  15704.482
                                  (* y -30.160366))))))))))))
             (ans2
              (+ 1.4472523E+11
                 (* y
                    (+ 2.3005353E+9
                       (* y
                          (+ 1.8583304E+7
                             (*
                              y
                              (+
                               99447.44
                               (* y (+ 376.99915 y)))))))))))
        (/ ans1 ans2))
      (let* ((ax (abs x))
             (z (/ 8.0 ax))
             (y (* z z))
             (xx (- ax 2.3561945))
             (ans1
              (+ 1.0
                 (* y
                    (+ 0.00183105
                       (* y
                          (+ -3.5163965E-5
                             (*
                              y
                              (+
                               2.4575202E-6
                               (* y -2.4033702E-7)))))))))
             (ans2
              (+ 0.046875
                 (* y
                    (+ -2.0026909E-4
                       (* y
                          (+ 8.449199E-6
                             (*
                              y
                              (+
                               -8.822899E-7
                               (* y 1.05787414E-7))))))))))
        (* (signum x)
           (sqrt (/ 0.63661975 ax))
           (- (* (cos xx) ans1) (* z (sin xx) ans2))))))

(defun import-spear-data (path &key (start 0) end point-format
                          freq-scaler amp-scaler time-scaler)
  (let ((ftype nil)
        (count nil)
        (file (open-file path ':input))
        (data (list))
        (err? t)
        (para nil)
        (parb nil))
    (unwind-protect
        (progn (loop for s = (file-line file)
                     until (or (file-eof? s)
                               (equal s "frame-data")
                               (equal s "partials-data"))
                     do (cond ((equal s "par-text-frame-format")
                               (setf ftype ':frames))
                              ((equal s "par-text-partials-format")
                               (setf ftype ':partials))
                              ((equal
                                s
                                "point-type time frequency amplitude")
                               nil)
                              ((equal
                                s
                                "point-type index frequency amplitude")
                               nil)
                              (t
                               (let
                                ((x (string-substrings s)))
                                (cond
                                 ((null x) nil)
                                 ((or
                                   (equal (car x) "partials-count")
                                   (equal (car x) "frame-count"))
                                  (setf
                                   count
                                   (read-from-string (cadr x)))))))))
                     (cond ((eq ftype ':frames)
                            (unless point-format
                              (setf
                               point-format
                               '(:hertz :amplitude)))
                            (cond ((consp point-format)
                                   (if
                                    (member
                                     (car point-format)
                                     '(:hertz :keynum :note))
                                    (setf para (car point-format))
                                    (error
                                     "import-spear-data: illegal point-format: ~s."
                                     point-format))
                                   (if
                                    (and
                                     (consp (cdr point-format))
                                     (eq
                                      (car (cdr point-format))
                                      ':amplitude))
                                    (setf parb t)
                                    (error
                                     "import-spear-data: illegal point-format: ~s."
                                     point-format)))
                                  ((member
                                    point-format
                                    '(:hertz :keynum :note :raw))
                                   (setf para point-format))
                                  (t
                                   (error
                                    "import-spear-data: ~s is not a valid point-format."
                                    point-format))))
                           ((eq ftype ':partials)
                            (unless point-format
                              (setf point-format '(:time :hertz)))
                            (cond ((consp point-format)
                                   (if
                                    (eq (car point-format) ':time)
                                    (setf para ':time)
                                    (error
                                     "import-spear-data: illegal point-format ~s."
                                     point-format))
                                   (if
                                    (and
                                     (consp (cdr point-format))
                                     (member
                                      (car (cdr point-format))
                                      '(:hertz :keynum :note)))
                                    (setf
                                     parb
                                     (car (cdr point-format)))
                                    (error
                                     "import-spear-data: illegal point-format ~s."
                                     point-format)))
                                  ((member
                                    point-format
                                    '(:hertz :keynum :note :raw))
                                   (setf parb point-format))
                                  (t
                                   (error
                                    "import-spear-data: ~s is not a valid point-format."
                                    point-format))))
                           (t
                            (error "import-spear-data: no frames or partials.")))
                     (unless count
                       (error "import-spear-data: file does not contain frame/partial count."))
                     (loop with d
                           for s = (file-line file)
                           for i from 0
                           until (file-eof? s)
                           do (when
                               (or
                                (and
                                 (>= i start)
                                 (or (not end) (<= i end))))
                               (if
                                (eq ftype ':partials)
                                (let
                                 ((hdr s))
                                 (setf s (file-line file))
                                 (setf
                                  d
                                  (read-spear-partial
                                   hdr
                                   s
                                   para
                                   parb
                                   freq-scaler
                                   amp-scaler)))
                                (setf
                                 d
                                 (read-spear-frame
                                  s
                                  para
                                  parb
                                  time-scaler
                                  freq-scaler)))
                               (if (consp d) (push d data))))
                           (setf err? nil))
                 (if file (close-file file ':input)))
               (if (not err?) (setf data (nreverse data)))
               data))

(defun read-spear-frame (str ftyp amp? freq-scaler amp-scaler)
  (let ((data (string->expr str :multiok t)))
    (if (eq ftyp ':raw)
        data
        (do ((tail (cddr data) (cdddr tail))
             (head (list))
             (freq nil)
             (ampl nil))
            ((null tail) (nreverse head))
          (setf freq (car (cdr tail)))
          (setf ampl (car (cddr tail)))
          (cond ((eq ftyp ':hertz)
                 (if freq-scaler (setf freq (* freq freq-scaler))))
                (t
                 (if freq-scaler
                     (setf freq (+ (keynum freq :hz t) freq-scaler))
                     (setf freq (keynum freq :hz t)))
                 (if (eq ftyp ':note) (setf freq (note freq)))))
          (push freq head)
          (if amp?
              (push (if amp-scaler (* ampl amp-scaler) ampl)
                    head))))))

(defun read-spear-partial (hdr str tim? ftyp time-scaler freq-scaler)
  hdr
  (let ((data (string->expr str :multiok t)))
    (if (eq ftyp ':raw)
        data
        (do ((tail data (cdddr tail))
             (head (list))
             (time nil)
             (freq nil))
            ((null tail) (nreverse head))
          (setf time (car tail))
          (setf freq (car (cdr tail)))
          (if tim?
              (push (if time-scaler (* time time-scaler) time) head))
          (cond ((eq ftyp ':hertz)
                 (if freq-scaler (setf freq (* freq freq-scaler))))
                (t
                 (if freq-scaler
                     (setf freq (+ (keynum freq :hz t) freq-scaler))
                     (setf freq (keynum freq :hz t)))
                 (if (eq ftyp ':note) (setf freq (note freq)))))
          (push freq head)))))

(defun spectrum-maxfreq (spec &optional fmat)
  (let ((freq (elt spec (- (length spec) 2))))
    (if (not fmat)
        freq
        (let ((type (spectrum-guess-type spec)))
          (case fmat
            ((:hertz :hz) (if (eq type ':hertz) freq (hertz freq)))
            ((:keynum)
             (if (eq fmat type)
                 freq
                 (keynum freq :hz (eq type ':hertz))))
            ((:note)
             (if (eq fmat type)
                 freq
                 (note freq :hz (eq type ':hertz))))
            (t
             (error "spectrum-maxfreq: ~s is not a frequency format."
                    fmat)))))))

(defun spectrum-minfreq (spec &optional fmat)
  (let ((freq (car spec)))
    (if (not fmat)
        freq
        (let ((type (spectrum-guess-type spec)))
          (case fmat
            ((:hertz :hz) (if (eq type ':hertz) freq (hertz freq)))
            ((:keynum)
             (if (eq fmat type)
                 freq
                 (keynum freq :hz (eq type ':hertz))))
            ((:note)
             (if (eq fmat type)
                 freq
                 (note freq :hz (eq type ':hertz))))
            (t
             (error "spectrum-minfreq: ~s is not a frequency format."
                    fmat)))))))

(defun spectrum-minamp (spec)
  (do ((tail (cdr spec) (cddr tail)) (mina most-positive-fixnum))
      ((null tail) (if (eq mina most-positive-fixnum) nil mina))
    (setf mina (min mina (car tail)))))

(defun spectrum-maxamp (spec)
  (do ((tail (cdr spec) (cddr tail)) (maxa most-negative-fixnum))
      ((null tail) (if (eq maxa most-negative-fixnum) nil maxa))
    (setf maxa (max maxa (car tail)))))

(defun spectrum-freqs (spec &optional fmat)
  (let* ((frqs (list nil)) (type (spectrum-guess-type spec)))
    (if (not fmat)
        (setf fmat type)
        (case fmat
          ((:note :notes) (setf fmat ':note))
          ((:keynum :keynums) (setf fmat ':keynum))
          ((:hertz :hz) (setf fmat ':hertz))
          (t
           (error "spectrum-freqs: ~s is not a frequency format."
                  fmat))))
    (do ((next spec (cddr next)) (tail frqs))
        ((null next) (cdr frqs))
      (setf (cdr tail)
            (list (cond ((eq type fmat) (car next))
                        ((eq fmat ':hertz) (hertz (car next)))
                        ((eq fmat ':keynum)
                         (keynum (car next) :hz (eq type ':hertz)))
                        (t
                         (note (car next) :hz (eq type ':hertz))))))
      (setf tail (cdr tail)))))

(defun spectrum-amps (spec)
  (let ((amps (list nil)))
    (do ((next (cdr spec) (cddr next)) (tail amps))
        ((null next) (cdr amps))
      (setf (cdr tail) (list (car next)))
      (setf tail (cdr tail)))))

(defun spectrum-guess-type (spec)
  (if (let ((t11 (car spec))) (and t11 (symbolp t11)))
      ':note
      (let ((max (spectrum-maxfreq spec)))
        (if (< max 138) ':keynum ':hertz))))

(defun convert-spectrum (spec fmat)
  (let ((head (list nil)) (mode 0) (type (spectrum-guess-type spec)))
    (case type ((:keynum) (setf mode 1)) ((:note) (setf mode 2)))
    (case fmat
      ((:keynum :keynums) (setf mode (logior mode 4)))
      ((:note :notes) (setf mode (logior mode 8)))
      ((:hertz :hz) nil)
      (t
       (error "convert-spectrum: ~s is not :note :keynum or :hertz"
              fmat)))
    (if (member mode '(0 5 10))
        spec
        (do ((next spec (cdr next))
             (tail head (cdr tail))
             (amp? nil (not amp?)))
            ((null next) (cdr head))
          (setf (cdr tail)
                (list (if amp?
                          (car next)
                          (case mode
                            ((4) (keynum (car next) :hz t))
                            ((8) (note (car next) :hz t))
                            ((1 2) (hertz (car next)))
                            ((9) (note (car next)))
                            ((6) (keynum (car next)))
                            (t
                             (error
                              "convert-spectrum: Shouldn't: mode is ~s"
                              mode))))))))))

(defun rescale-spectrum (spec &optional f1 f2 a1 a2)
  (let* ((fmat (spectrum-guess-type spec))
         (amp? (or a1 a2))
         (next
          (if (eq fmat ':hertz)
              (append spec (list))
              (convert-spectrum spec ':hertz))))
    (when amp?
      (let ((mina (spectrum-minamp next))
            (maxa (spectrum-maxamp next)))
        (if (not a1) (setf a1 mina))
        (if (not a2) (setf a2 maxa))
        (do ((tail (cdr next) (cddr tail)))
            ((null tail) nil)
          (setf (car tail) (rescale (car tail) mina maxa a1 a2)))))
    (unless (and (eq fmat ':hertz) (not f1) (not f2))
      (let ((oldmin (spectrum-minfreq next))
            (oldmax (spectrum-maxfreq next))
            (newmin nil)
            (newmax nil))
        (cond ((eq fmat ':hertz)
               (setf newmin (or f1 oldmin))
               (setf newmax (or f2 oldmax)))
              (t
               (setf newmin (if f1 (hertz f1) oldmin))
               (setf newmax (if f2 (hertz f2) oldmax))))
        (do ((tail next (cddr tail)))
            ((null tail) nil)
          (setf (car tail)
                (rescale (car tail) oldmin oldmax newmin newmax))
          (if (eq fmat ':keynum)
              (setf (car tail) (keynum (car tail) :hz t))
              (if (eq fmat ':note)
                  (setf (car tail) (note (car tail) :hz t)))))))
    next))

(defun invert-spectrum (spec &optional amps?)
  (let* ((isa (spectrum-guess-type spec))
         (new
          (if (eq isa ':note)
              (convert-spectrum spec ':keynum)
              (append spec (list))))
         (bot (spectrum-minfreq new))
         (top (spectrum-maxfreq new))
         (len (length new)))
    (do ((tail new (cddr tail))
         (soft (if amps? (spectrum-minamp new) nil))
         (loud (if amps? (spectrum-maxamp new) nil)))
        ((null tail) nil)
      (rplaca tail (rescale (car tail) bot top top bot))
      (if soft
          (rplaca (cdr tail)
                  (rescale (cadr tail) soft loud loud soft)))
      (if (eq isa ':note) (rplaca tail (note (car tail)))))
    (do ((head 0 (+ head 2)) (tail (- len 2) (- tail 2)) (temp nil))
        ((not (< head tail)) nil)
      (setf temp (elt new head))
      (setf (elt new head) (elt new tail))
      (setf (elt new tail) temp))
    new))

(defun spectrum->midi (spec &rest args)
  (let* ((type (spectrum-guess-type spec))
         (amps
          (if (eq (getf args ':amplitude) t)
              (spectrum-amps spec)
              nil))
         (keys
          (spectrum-freqs spec (if (eq type ':hertz) ':keynum nil)))
         (head (list nil)))
    (if (not amps)
        (do ((klis keys (cdr klis)) (tail head))
            ((null klis) (cdr head))
          (setf (cdr tail)
                (list (apply #'make-instance
                             (find-class 'midi)
                             :keynum
                             (car klis)
                             args)))
          (setf tail (cdr tail)))
        (do ((ampl (member ':amplitude args))
             (klis keys (cdr klis))
             (alis amps (cdr alis))
             (tail head))
            ((null klis) (cdr head))
          (setf (car (cdr ampl)) (car alis))
          (setf (cdr tail)
                (list (apply #'make-instance
                             (find-class 'midi)
                             :keynum
                             (car klis)
                             args)))
          (setf tail (cdr tail))))))
