;;; **********************************************************************
;;; Copyright (C) 2009 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from sc.scm on 04-Aug-2009 14:11:46

(in-package :cm)

(defparameter *scsynth* ())

(defparameter *sc-plugin-path* ())

(defparameter *sc-synthdef-path* ())

(defmethod make-byte-vector ((int integer))
  (u8vector (ash (logand int 4278190080) -24)
   (ash (logand int 16711680) -16) (ash (logand int 65280) -8)
   (logand int 255)))

(defmethod make-byte-vector ((flo float))
  (if (zerop flo)
      (make-u8vector 4 0)
      (multiple-value-bind (signif expon sign)
          (integer-decode-float flo)
        (let ((sign-bit (if (< sign 0) 2147483648 0))
              (exponent (+ expon 23 127))
              (fraction (logand (round signif) 8388607)))
          (make-byte-vector
           (logior sign-bit (ash exponent 23) fraction))))))

(defmethod make-byte-vector ((str string))
  (let* ((len (length str))
         (pad (- 4 (mod len 4)))
         (vec (make-u8vector (+ len pad) 0)))
    (do ((i 0 (+ i 1)))
        ((= i len) vec)
      (u8vector-set! vec i (char-code (elt str i))))))

(defmethod make-byte-vector ((sym symbol))
  (let ((str (string-downcase (symbol-name sym))))
    (make-byte-vector str)))

(defun make-file-timetag (offset)
  (multiple-value-bind (int rem)
      (floor offset)
    (u8vector-append (make-byte-vector int)
     (make-byte-vector (floor (* rem 4294967295))))))

(defmethod return-type-code ((int integer)) int (char-code #\i))

(defmethod return-type-code ((flo float)) flo (char-code #\f))

(defmethod return-type-code ((str string)) str (char-code #\s))

(defmethod return-type-code ((sym symbol)) sym (char-code #\s))

(defun make-type-array (message)
  (let* ((mes (cdr message))
         (len (length mes))
         (pad (- 4 (mod len 4)))
         (vec (make-u8vector (+ len (if (= pad 1) (+ pad 4) pad)))))
    (u8vector-set! vec 0 (char-code #\,))
    (do ((i 0 (+ i 1)))
        ((= i len) vec)
      (u8vector-set! vec (+ i 1) (return-type-code (elt mes i))))))

(defmethod get-first-obj ((num number))
  (make-byte-vector (format nil "~s" num)))

(defmethod get-first-obj ((str string)) (make-byte-vector str))

(defmethod get-first-obj ((sym symbol))
  (make-byte-vector (string-downcase (symbol-name sym))))

(defun format-osc (message)
  (let ((arr
         (apply #'u8vector-append
                (get-first-obj (car message))
                (make-type-array message)
                (loop for m in (cdr message)
                      collect (make-byte-vector m)))))
        (values arr (u8vector-length arr))))

(let ((os (os-name)))
  (cond ((member os '(darwin osx))
         (setf *scsynth*
               (if (probe-file "/Applications/SuperCollider3/scsynth")
                   "/Applications/SuperCollider3/scsynth"
                   (if (probe-file "/Applications/SuperCollider_f/scsynth")
                       "/Applications/SuperCollider_f/scsynth"
                       nil)))
         (when *scsynth*
           (setf *sc-plugin-path*
                 (concatenate 'string
                              (filename-directory *scsynth*)
                              "plugins"))
           (setf *sc-synthdef-path*
                 (concatenate 'string
                              (filename-directory *scsynth*)
                              "synthdefs"))))
        ((member os '(linux unix))
         (setf *scsynth*
               (if (probe-file "/usr/local/bin/scsynth")
                   "/usr/local/bin/scsynth"
                   (if (probe-file "/usr/bin/scsynth")
                       "/usr/bin/scsynth"
                       nil))))
        ((member os '(win32))
         (when (probe-file "/Program Files/SuperCollider3/scsynth.exe")
           (let ((dir "/Program Files/SuperCollider3/"))
             (setf *scsynth* (namestring (truename dir)))
             (setf *sc-plugin-path*
                   (namestring (truename
                                (concatenate
                                 'string
                                 dir
                                 "plugins/"))))
             (setf *sc-synthdef-path*
                   (namestring (truename
                                (concatenate
                                 'string
                                 dir
                                 "synthdefs/")))))))))

(progn (defclass sc-file (event-file)
         ((elt-type :initform :byte :initarg :elt-type :accessor
           file-elt-type))
         #+metaclasses
         (:metaclass io-class))
       (defparameter <sc-file> (find-class 'sc-file))
       (finalize-class <sc-file>)
       (setf (io-class-file-types <sc-file>) '("*.osc"))
       (values))

(defmethod close-io :before ((io sc-file) &rest mode) mode (if
                                                            (equal
                                                             (io-direction
                                                              io)
                                                             :output)
                                                            (let
                                                             ((pad
                                                               (getf
                                                                (event-stream-args
                                                                 io)
                                                                ':pad)))
                                                             (if
                                                              pad
                                                              (write-bundle
                                                               (+
                                                                pad
                                                                (object-time
                                                                 io))
                                                               '("/none")
                                                               io)
                                                              (write-bundle
                                                               (+
                                                                5
                                                                (object-time
                                                                 io))
                                                               '("/none")
                                                               io)))))

(defun set-sc-output-hook! (fn)
  (unless (or (not fn) (functionp fn))
    (error "Not a supercollider file hook: ~s" fn))
  (setf (io-class-output-hook <sc-file>) fn)
  (values))

(defparameter *sc-audio-format-types* (list
                                       :int8
                                       "int8"
                                       :int16
                                       "int16"
                                       :int32
                                       "int32"
                                       :float
                                       "float"
                                       :double
                                       "double"
                                       :ulaw
                                       "ulaw"
                                       :alaw
                                       "alaw"))

(defparameter *sc-audio-header-types* (list
                                       :aiff
                                       "AIFF"
                                       :wav
                                       "WAV"
                                       :sun
                                       "SUN"
                                       :ircam
                                       "IRCAM"
                                       :raw
                                       "RAW"))

(defun play-sc-file (file &rest args)
  (let ((playit (getf args ':play t)))
    (if (and *scsynth* playit)
        (let* ((output (getf args ':output))
               (channels (getf args ':channels 2))
               (fmat (getf args ':format ':int16))
               (header nil)
               (srate (getf args ':srate 44100))
               (verbose (getf args ':verbose))
               (wait (getf args ':wait playit))
               (osc-file file)
               (output-file nil)
               (command nil))
          (if output
              (if (filename-directory output)
                  (setf output-file output)
                  (setf output-file
                        (concatenate 'string
                                     (or
                                      (filename-directory osc-file)
                                      "")
                                     output)))
              (setf output-file
                    (concatenate 'string
                                 (or
                                  (filename-directory osc-file)
                                  "")
                                 "test.wav")))
          (do ((l (length *sc-audio-header-types*))
               (f (filename-type output-file))
               (i 1 (+ i 2))
               (x nil))
              ((or header (not (< i l)))
               (unless header
                 (error "Output file type ~s not one of ~s."
                        f
                        *sc-audio-header-types*)))
            (setf x (elt *sc-audio-header-types* i))
            (if (string-equal f x) (setf header x)))
          (if (and (not (env-var "SC_SYNTHDEF_PATH"))
                   *sc-synthdef-path*)
              (set-env-var "SC_SYNTHDEF_PATH" *sc-synthdef-path*))
          (if (and (not (env-var "SC_PLUGIN_PATH")) *sc-plugin-path*)
              (set-env-var "SC_PLUGIN_PATH" *sc-plugin-path*))
          (setf command
                (format nil
                        "~A -m 81920 -N ~A _ ~A ~A ~A ~A -o ~A"
                        *scsynth*
                        osc-file
                        output-file
                        srate
                        header
                        (getf *sc-audio-format-types* fmat)
                        channels))
          (if verbose (format t "~%; ~a" command))
          (shell command :wait wait :output verbose)
          (if playit (play output-file :wait nil))
          file)
        nil)))

(set-sc-output-hook! #'play-sc-file)

(defmethod write-bundle (offset message (io sc-file))
  (let ((fd (io-open io)) (arr nil) (bundle-len nil))
    (multiple-value-bind (mess len)
        (format-osc message)
      (setf bundle-len (+ len 8 8 4))
      (setf arr
            (u8vector-append (make-byte-vector bundle-len)
             (make-byte-vector "#bundle") (make-file-timetag offset)
             (make-byte-vector len) mess))
      (u8vector-write arr fd))))

(defmethod initialize-io ((io sc-file))
  (when (eq (io-direction io) ':output)
    (write-bundle 0 (list "/g_new" 1 0 0) io)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (progn (defclass sc-cmd (event) nil)
         (defparameter <sc-cmd> (find-class 'sc-cmd))
         (finalize-class <sc-cmd>)
         (values)))

(defobject load-synthdef (sc-cmd) ((path :initform nil))
 (:parameters path) (:event-streams))

(defun load-synthdef (path) (list "/d_load" path))

(defmethod write-event ((obj load-synthdef) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (load-synthdef (slot-value obj 'path)) io))

(defmethod import-set-slots ((obj load-synthdef) l)
  (setf (slot-value obj 'path) (first l)))

(defobject load-synthdef-dir (sc-cmd) ((path :initform nil))
 (:parameters path) (:event-streams))

(defun load-synthdef-dir (path) (list "/d_loadDir" path))

(defmethod write-event ((obj load-synthdef-dir) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (load-synthdef-dir (slot-value obj 'path)) io))

(defmethod import-set-slots ((obj load-synthdef-dir) l)
  (setf (slot-value obj 'path) (pop l)))

(defobject node-free (sc-cmd) ((node :initform nil))
 (:parameters node) (:event-streams))

(defun node-free (nodes)
  (let ((msg nil))
    (cond ((numberp nodes) (setf msg (list "/n_free" nodes)))
          ((consp nodes) (setf msg (append '("/n_free") nodes)))
          (t
           (error "node-free: expect number or list but got ~s instead."
                  nodes)))
    msg))

(defmethod write-event ((obj node-free) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (node-free (slot-value obj 'node)) io))

(defmethod import-set-slots ((obj node-free) lst)
  (let ((len (length lst)))
    (if (= len 1)
        (setf (slot-value obj 'node) (pop lst))
        (setf (slot-value obj 'node) lst))))

(defobject node-run (sc-cmd)
 ((node :initform nil) (flag :initform nil)) (:parameters node flag)
 (:event-streams))

(defun node-run (node flag)
  (let ((msg nil))
    (if (consp node)
        (progn (setf msg (list "/n_run"))
               (dotimes (i (length node))
                 (setf msg
                       (nconc msg
                              (list
                               (elt node i)
                               (if (elt flag i) 1 0))))))
        (setf msg (list "/n_run" node (if flag 1 0))))
    msg))

(defmethod write-event ((obj node-run) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-run (slot-value obj 'node) (slot-value obj 'flag)) io))

(defmethod import-set-slots ((obj node-run) lst)
  (let ((len (length lst)))
    (if (= len 2)
        (progn (setf (slot-value obj 'node) (pop lst))
               (setf (slot-value obj 'flag) (pop lst)))
        (do ((i 0 (+ i 2)))
            ((= i len))
          (setf (slot-value obj 'node)
                (nconc (slot-value obj 'node) (list (elt lst i))))
          (setf (slot-value obj 'flag)
                (nconc (slot-value obj 'flag)
                       (list (elt lst (+ 1 i)))))))))

(defobject node-set (sc-cmd)
 ((node :initform nil) (controls-values :initform nil))
 (:parameters node controls-values) (:event-streams))

(defun node-set (node ctrl-values)
  (let ((msg nil))
    (setf msg (list "/n_set" node))
    (dolist (i ctrl-values)
      (if (keyword? i)
          (setf msg (nconc msg (list (keyword->string i))))
          (setf msg (nconc msg (list (coerce i 'single-float))))))
    msg))

(defmethod write-event ((obj node-set) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-set (slot-value obj 'node)
    (slot-value obj 'controls-values))
   io))

(defmethod import-set-slots ((obj node-set) lst)
  (let ((cv '()) (len 0))
    (setf (slot-value obj 'node) (pop lst))
    (setf len (length lst))
    (do ((i 0 (+ i 2)))
        ((= i len))
      (setf cv
            (nconc cv
                   (list (string->keyword (elt lst i))
                         (elt lst (+ 1 i))))))
    (setf (slot-value obj 'controls-values) cv)))

(defobject node-setn (sc-cmd)
 ((node :initform nil) (controls-values :initform nil))
 (:parameters node controls-values) (:event-streams))

(defun node-setn (node ctrl-values)
  (let ((msg nil))
    (setf msg (list "/n_setn" node))
    (dolist (i ctrl-values)
      (if (keyword? i)
          (setf msg (nconc msg (list (keyword->string i))))
          (if (consp i)
              (progn (setf msg (nconc msg (list (length i))))
                     (dolist (j i)
                       (setf msg
                             (nconc
                              msg
                              (list (coerce j 'single-float))))))
              (setf msg
                    (nconc msg (list (coerce i 'single-float)))))))
    msg))

(defmethod write-event ((obj node-setn) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-setn (slot-value obj 'node)
    (slot-value obj 'controls-values))
   io))

(defmethod import-set-slots ((obj node-setn) lst)
  (let ((cv '()) (len 0) (num-vals 0))
    (setf (slot-value obj 'node) (pop lst))
    (setf len (length lst))
    (do ((i 0))
        ((= i len))
      (setf cv (nconc cv (list (string->keyword (elt lst i)))))
      (setf num-vals (elt lst (incf i)))
      (dotimes (j num-vals)
        (setf cv (nconc cv (list (elt lst (incf i))))))
      (incf i))
    (setf (slot-value obj 'controls-values) cv)))

(defobject node-fill (sc-cmd)
 ((node :initform nil) (control :initform nil)
  (num-controls :initform nil) (value :initform nil))
 (:parameters node control num-controls value) (:event-streams))

(defun node-fill (node control num-controls val)
  (let ((msg nil))
    (setf msg (list "/n_fill" node))
    (if (consp control)
        (progn (dotimes (i (length control))
                 (setf msg
                       (nconc msg
                              (list
                               (keyword->string (elt control i))
                               (elt num-controls i)
                               (coerce
                                (elt val i)
                                'single-float))))))
        (setf msg
              (list "/n_fill"
                    node
                    (keyword->string control)
                    num-controls
                    (coerce val 'single-float))))
    msg))

(defmethod write-event ((obj node-fill) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-fill (slot-value obj 'node) (slot-value obj 'control)
    (slot-value obj 'num-controls) (slot-value obj 'value))
   io))

(defmethod import-set-slots ((obj node-fill) lst)
  (let ((len 0))
    (setf (slot-value obj 'node) (pop lst))
    (setf len (length lst))
    (if (= len 3)
        (progn (setf (slot-value obj 'control)
                     (string->keyword (pop lst)))
               (setf (slot-value obj 'num-controls) (pop lst))
               (setf (slot-value obj 'value) (pop lst)))
        (do ((i 0 (+ i 3)))
            ((= i len))
          (setf (slot-value obj 'control)
                (nconc (slot-value obj 'control) (list (elt lst i))))
          (setf (slot-value obj 'num-controls)
                (nconc (slot-value obj 'num-controls)
                       (list (elt lst (+ 1 i)))))
          (setf (slot-value obj 'value)
                (nconc (slot-value obj 'value)
                       (list (elt lst (+ 2 i)))))))))

(defobject node-map (sc-cmd)
 ((node :initform nil) (controls-buses :initform nil))
 (:parameters node controls-buses) (:event-streams))

(defun node-map (node ctrl-buses)
  (let ((msg nil))
    (setf msg (list "/n_map" node))
    (dolist (i ctrl-buses)
      (if (keyword? i)
          (setf msg (nconc msg (list (keyword->string i))))
          (setf msg (nconc msg (list i)))))
    msg))

(defmethod write-event ((obj node-map) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-map (slot-value obj 'node) (slot-value obj 'controls-buses))
   io))

(defmethod import-set-slots ((obj node-map) lst)
  (let ((cb nil) (len 0))
    (setf (slot-value obj 'node) (pop lst))
    (setf len (length lst))
    (do ((i 0 (+ i 2)))
        ((= i len))
      (setf cb
            (nconc cb
                   (list (string->keyword (elt lst i))
                         (elt lst (+ 1 i))))))
    (setf (slot-value obj 'controls-buses) cb)))

(defobject node-mapn (sc-cmd)
 ((node :initform nil) (control :initform nil) (bus :initform nil)
  (num-controls :initform nil))
 (:parameters node control bus num-controls) (:event-streams))

(defun node-mapn (node control bus num-controls)
  (let ((msg nil))
    (setf msg (list "/n_mapn" node))
    (if (consp control)
        (progn (dotimes (i (length control))
                 (setf msg
                       (nconc msg
                              (list
                               (keyword->string (elt control i))
                               (elt bus i)
                               (elt num-controls i))))))
        (setf msg
              (list "/n_mapn"
                    node
                    (keyword->string control)
                    bus
                    num-controls)))))

(defmethod write-event ((obj node-mapn) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-mapn (slot-value obj 'node) (slot-value obj 'control)
    (slot-value obj 'value) (slot-value obj 'num-controls))
   io))

(defmethod import-set-slots ((obj node-mapn) lst)
  (let ((len 0))
    (setf (slot-value obj 'node) (pop lst))
    (setf len (length lst))
    (if (= len 3)
        (progn (setf (slot-value obj 'control)
                     (string->keyword (pop lst)))
               (setf (slot-value obj 'bus) (pop lst))
               (setf (slot-value obj 'num-controls) (pop lst)))
        (do ((i 0 (+ i 3)))
            ((= i len))
          (setf (slot-value obj 'control)
                (nconc (slot-value obj 'control) (list (elt lst i))))
          (setf (slot-value obj 'bus)
                (nconc (slot-value obj 'bus)
                       (list (elt lst (+ 1 i)))))
          (setf (slot-value obj 'num-controls)
                (nconc (slot-value obj 'num-controls)
                       (list (elt lst (+ 2 i)))))))))

(defobject node-before (sc-cmd)
 ((node :initform nil) (before :initform nil))
 (:parameters node before) (:event-streams))

(defun node-before (node before-node)
  (let ((msg nil))
    (if (consp node)
        (progn (setf msg (list "/n_before"))
               (dotimes (i (length node))
                 (setf msg
                       (nconc msg
                              (list
                               (elt node i)
                               (elt before-node i))))))
        (setf msg (list "/n_before" node before-node)))
    msg))

(defmethod write-event ((obj node-before) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-before (slot-value obj 'node) (slot-value obj 'before)) io))

(defmethod import-set-slots ((obj node-before) lst)
  (let ((len 0))
    (setf len (length lst))
    (if (= len 2)
        (progn (setf (slot-value obj 'node) (pop lst))
               (setf (slot-value obj 'before) (pop lst)))
        (do ((i 0 (+ i 2)))
            ((= i len))
          (setf (slot-value obj 'node)
                (nconc (slot-value obj 'node) (list (elt lst i))))
          (setf (slot-value obj 'before)
                (nconc (slot-value obj 'before)
                       (list (elt lst (+ 1 i)))))))))

(defobject node-after (sc-cmd)
 ((node :initform nil) (after :initform nil))
 (:parameters node after) (:event-streams))

(defun node-after (node after-node)
  (let ((msg nil))
    (if (consp node)
        (progn (setf msg (list "/n_after"))
               (dotimes (i (length node))
                 (setf msg
                       (nconc msg
                              (list
                               (elt node i)
                               (elt after-node i))))))
        (setf msg (list "/n_after" node after-node)))
    msg))

(defmethod write-event ((obj node-after) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (node-after (slot-value obj 'node) (slot-value obj 'after)) io))

(defmethod import-set-slots ((obj node-after) lst)
  (let ((len 0))
    (setf len (length lst))
    (if (= len 2)
        (progn (setf (slot-value obj 'node) (pop lst))
               (setf (slot-value obj 'after) (pop lst)))
        (do ((i 0 (+ i 2)))
            ((= i len))
          (setf (slot-value obj 'node)
                (nconc (slot-value obj 'node) (list (elt lst i))))
          (setf (slot-value obj 'after)
                (nconc (slot-value obj 'after)
                       (list (elt lst (+ 1 i)))))))))

(defobject group-new (sc-cmd)
 ((id :initform nil) (add-action :initform 0) (target :initform 0))
 (:parameters id add-action target) (:event-streams))

(defun group-new (new-id action target)
  (let ((msg nil))
    (if (consp new-id)
        (progn (setf msg (list "/g_new"))
               (dotimes (i (length new-id))
                 (setf msg
                       (nconc msg
                              (list
                               (elt new-id i)
                               (elt action i)
                               (elt target i))))))
        (setf msg (list "/g_new" new-id action target)))
    msg))

(defmethod write-event ((obj group-new) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (group-new (slot-value obj 'id) (slot-value obj 'add-action)
    (slot-value obj 'target))
   io))

(defmethod import-set-slots ((obj group-new) lst)
  (let ((len 0))
    (setf len (length lst))
    (if (= len 3)
        (progn (setf (slot-value obj 'id) (pop lst))
               (setf (slot-value obj 'add-action) (pop lst))
               (setf (slot-value obj 'target) (pop lst)))
        (do ((i 0 (+ i 3)))
            ((= i len))
          (setf (slot-value obj 'id)
                (nconc (slot-value obj 'id) (list (elt lst i))))
          (setf (slot-value obj 'add-action)
                (nconc (slot-value obj 'add-action)
                       (list (elt lst (+ 1 i)))))
          (setf (slot-value obj 'target)
                (nconc (slot-value obj 'target)
                       (list (elt lst (+ 2 i)))))))))

(defobject group-head (sc-cmd)
 ((node :initform nil) (group :initform nil))
 (:parameters node group) (:event-streams))

(defun group-head (group node)
  (let ((msg nil))
    (if (consp group)
        (progn (setf msg (list "/g_head"))
               (dotimes (i (length group))
                 (setf msg
                       (nconc msg
                              (list (elt group i) (elt node i))))))
        (setf msg (list "/g_head" group node)))
    msg))

(defmethod write-event ((obj group-head) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (group-head (slot-value obj 'group) (slot-value obj 'node)) io))

(defmethod import-set-slots ((obj group-head) lst)
  (let ((len (length lst)))
    (if (= len 2)
        (progn (setf (slot-value obj 'node) (pop lst))
               (setf (slot-value obj 'group) (pop lst)))
        (do ((i 0 (+ i 2)))
            ((= i len))
          (setf (slot-value obj 'node)
                (nconc (slot-value obj 'node) (list (elt lst i))))
          (setf (slot-value obj 'group)
                (nconc (slot-value obj 'group)
                       (list (elt lst (+ 1 i)))))))))

(defobject group-tail (sc-cmd)
 ((node :initform nil) (group :initform nil))
 (:parameters node group) (:event-streams))

(defun group-tail (group node)
  (let ((msg nil))
    (if (consp group)
        (progn (setf msg (list "/g_tail"))
               (dotimes (i (length group))
                 (setf msg
                       (nconc msg
                              (list (elt group i) (elt node i))))))
        (setf msg (list "/g_tail" group node)))
    msg))

(defmethod write-event ((obj group-tail) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (group-tail (slot-value obj 'group) (slot-value obj 'node)) io))

(defmethod import-set-slots ((obj group-tail) lst)
  (let ((len (length lst)))
    (if (= len 2)
        (progn (setf (slot-value obj 'node) (pop lst))
               (setf (slot-value obj 'group) (pop lst)))
        (do ((i 0 (+ i 2)))
            ((= i len))
          (setf (slot-value obj 'node)
                (nconc (slot-value obj 'node) (list (elt lst i))))
          (setf (slot-value obj 'group)
                (nconc (slot-value obj 'group)
                       (list (elt lst (+ 1 i)))))))))

(defobject group-free-all (sc-cmd) ((group :initform nil))
 (:parameters group) (:event-streams))

(defun group-free-all (group)
  (let ((msg nil))
    (if (consp group)
        (setf msg (nconc (list "/g_freeAll") group))
        (setf msg (list "/g_freeAll" group)))
    msg))

(defmethod write-event ((obj group-free-all) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (group-free-all (slot-value obj 'group)) io))

(defmethod import-set-slots ((obj group-free-all) lst)
  (let ((len (length lst)))
    (if (= len 1)
        (setf (slot-value obj 'group) (pop lst))
        (setf (slot-value obj 'group) lst))))

(defobject group-deep-free (sc-cmd) ((group :initform nil))
 (:parameters group) (:event-streams))

(defun group-deep-free (group)
  (let ((msg nil))
    (if (consp group)
        (setf msg (nconc (list "/g_deepFree") group))
        (setf msg (list "/g_deepFree" group)))
    msg))

(defmethod write-event ((obj group-deep-free) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (group-deep-free (slot-value obj 'group)) io))

(defmethod import-set-slots ((obj group-deep-free) lst)
  (let ((len (length lst)))
    (if (= len 1)
        (setf (slot-value obj 'group) (pop lst))
        (setf (slot-value obj 'group) lst))))

(defobject ugen-command (sc-cmd)
 ((node :initform nil) (ugen-index :initform nil)
  (command-name :initform nil) (args :initform nil))
 (:parameters node ugen-index command-name args) (:event-streams))

(defun ugen-command (node ugen-index command-name rest)
  (let ((msg nil))
    (setf msg (list "/u_cmd" node ugen-index command-name))
    (setf msg (append msg rest))
    msg))

(defmethod write-event ((obj ugen-command) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (ugen-command (slot-value obj 'node) (slot-value obj 'ugen-index)
    (slot-value obj 'command-name) (slot-value obj 'args))
   io))

(defmethod import-set-slots ((obj ugen-command) lst)
  (setf (slot-value obj 'node) (pop lst))
  (setf (slot-value obj 'ugen-index) (pop lst))
  (setf (slot-value obj 'command-name) (pop lst))
  (setf (slot-value obj 'args) (pop lst)))

(defobject buffer-alloc (sc-cmd)
 ((bufnum :initform nil) (frames :initform nil)
  (channels :initform 1))
 (:parameters bufnum frames channels) (:event-streams))

(defun buffer-alloc (buf-num num-frames num-chans)
  (list "/b_alloc" buf-num num-frames num-chans))

(defmethod write-event ((obj buffer-alloc) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-alloc (slot-value obj 'bufnum) (slot-value obj 'frames)
    (slot-value obj 'channels))
   io))

(defmethod import-set-slots ((obj buffer-alloc) lst)
  (setf (slot-value obj 'bufnum) (pop lst))
  (setf (slot-value obj 'frames) (pop lst))
  (setf (slot-value obj 'channels) (pop lst)))

(defobject buffer-alloc-read (sc-cmd)
 ((bufnum :initform nil) (file :initform nil)
  (start-frame :initform 0) (frames :initform 0))
 (:parameters bufnum frames start-frame file) (:event-streams))

(defun buffer-alloc-read (buf-num file start-frame num-frames)
  (let ((msg nil))
    (setf msg
          (list "/b_allocRead" buf-num file start-frame num-frames))
    msg))

(defmethod write-event ((obj buffer-alloc-read) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-alloc-read (slot-value obj 'bufnum) (slot-value obj 'file)
    (slot-value obj 'start-frame) (slot-value obj 'frames))
   io))

(defmethod import-set-slots ((obj buffer-alloc-read) lst)
  (setf (slot-value obj 'bufnum) (pop lst))
  (setf (slot-value obj 'file) (pop lst))
  (setf (slot-value obj 'start-frame) (pop lst))
  (setf (slot-value obj 'frames) (pop lst)))

(defobject buffer-read (sc-cmd)
 ((bufnum :initform nil) (file :initform nil)
  (start-frame :initform 0) (frames :initform -1)
  (buffer-start-frame :initform 0) (leave-open? :initform nil))
 (:parameters bufnum file start-frame frames buffer-start-frame
  leave-open?)
 (:event-streams))

(defun buffer-read (buf-num file start-frame num-frames
                    buf-start-frame leave-open?)
  (let ((msg nil))
    (setf msg
          (list "/b_read"
                buf-num
                file
                start-frame
                num-frames
                buf-start-frame
                (if leave-open? 1 0)))
    msg))

(defmethod write-event ((obj buffer-read) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-read (slot-value obj 'bufnum) (slot-value obj 'file)
    (slot-value obj 'start-frame) (slot-value obj 'frames)
    (slot-value obj 'buffer-start-frame)
    (slot-value obj 'leave-open?))
   io))

(defmethod import-set-slots ((obj buffer-read) lst)
  (setf (slot-value obj 'bufnum) (pop lst))
  (setf (slot-value obj 'file) (pop lst))
  (setf (slot-value obj 'start-frame) (pop lst))
  (setf (slot-value obj 'frames) (pop lst))
  (setf (slot-value obj 'buffer-start-frame) (pop lst))
  (setf (slot-value obj 'leave-open?) (pop lst)))

(defobject buffer-write (sc-cmd)
 ((bufnum :initform nil) (file :initform nil) (header :initform nil)
  (sample-format :initform nil) (frames :initform nil)
  (start-frame :initform nil) (leave-open? :initform nil))
 (:parameters bufnum file start-frame frames start-frame leave-open?)
 (:event-streams))

(defun buffer-write (buf-num file header-format sample-format
                     num-frames start-frame leave-open?)
  (let ((msg nil))
    (setf msg
          (list "/b_write"
                buf-num
                file
                (if (keyword? header-format)
                    (getf *sc-audio-header-types* header-format)
                    header-format)
                (if (keyword? sample-format)
                    (getf *sc-audio-format-types* sample-format)
                    sample-format)
                sample-format
                num-frames
                start-frame
                leave-open?))
    msg))

(defmethod write-event ((obj buffer-write) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-write (slot-value obj 'bufnum) (slot-value obj 'file)
    (slot-value obj 'header) (slot-value obj 'sample-format)
    (slot-value obj 'frames) (slot-value obj 'start-frame)
    (slot-value obj 'leave-open?))
   io))

(defmethod import-set-slots ((obj buffer-write) lst)
  (setf (slot-value obj 'bufnum) (pop lst))
  (setf (slot-value obj 'file) (pop lst))
  (setf (slot-value obj 'header) (pop lst))
  (setf (slot-value obj 'sample-format) (pop lst))
  (setf (slot-value obj 'frames) (pop lst))
  (setf (slot-value obj 'start-frame) (pop lst))
  (setf (slot-value obj 'leave-open?) (pop lst)))

(defobject buffer-free (sc-cmd) ((bufnum :initform nil))
 (:parameters bufnum) (:event-streams))

(defun buffer-free (buf-num) (list "/b_free" buf-num))

(defmethod write-event ((obj buffer-free) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (buffer-free (slot-value obj 'bufnum)) io))

(defmethod import-set-slots ((obj buffer-free) lst)
  (setf (slot-value obj 'bufnum) (pop lst)))

(defobject buffer-zero (sc-cmd) ((bufnum :initform nil))
 (:parameters bufnum) (:event-streams))

(defun buffer-zero (buf-num) (list "/b_zero" buf-num))

(defmethod write-event ((obj buffer-zero) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (buffer-zero (slot-value obj 'bufnum)) io))

(defmethod import-set-slots ((obj buffer-zero) lst)
  (setf (slot-value obj 'bufnum) (pop lst)))

(defobject buffer-set (sc-cmd)
 ((bufnum :initform nil) (samples-values :initform nil))
 (:parameters bufnum samples-values) (:event-streams))

(defun buffer-set (buf-num sample-values)
  (let ((msg nil))
    (setf msg (list "/b_set" buf-num))
    (dolist (i sample-values) (setf msg (nconc msg i)))
    msg))

(defmethod write-event ((obj buffer-set) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-set (slot-value obj 'bufnum)
    (slot-value obj 'sample-values))
   io))

(defmethod import-set-slots ((obj buffer-set) lst)
  (setf (slot-value obj 'bufnum) (pop lst))
  (setf (slot-value obj 'samples-values) lst))

(defobject buffer-setn (sc-cmd)
 ((bufnum :initform nil) (samples-values :initform nil))
 (:parameters bufnum samples-values) (:event-streams))

(defun buffer-setn (buf-num samples-values)
  (let ((msg nil))
    (setf msg (list "/b_setn" buf-num))
    (dolist (i samples-values)
      (if (consp i)
          (progn (setf msg (nconc msg (list (length i))))
                 (dolist (j i) (setf msg (nconc msg (list j)))))
          (setf msg (nconc msg (list i)))))
    msg))

(defmethod write-event ((obj buffer-setn) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-setn (slot-value obj 'bufnum)
    (slot-value obj 'samples-values))
   io))

(defmethod import-set-slots ((obj buffer-setn) lst)
  (let ((bv '()) (len 0) (num-vals 0) (s-vals '()))
    (setf (slot-value obj 'bufnum) (pop lst))
    (setf len (length lst))
    (do ((i 0))
        ((= i len))
      (setf bv (nconc bv (list (elt lst i))))
      (setf num-vals (elt lst (incf i)))
      (dotimes (j num-vals)
        (setf s-vals (nconc s-vals (list (elt lst (incf i))))))
      (setf bv (nconc bv (list s-vals)))
      (incf i))
    (setf (slot-value obj 'samples-values) bv)
    obj))

(defobject buffer-fill (sc-cmd)
 ((bufnum :initform nil) (start-sample :initform 0)
  (num-samples :initform nil) (value :initform nil))
 (:parameters bufnum start-sample num-samples value) (:event-streams))

(defun buffer-fill (buf-num start-sample num-samples val)
  (let ((msg (list "/b_fill" buf-num)))
    (if (consp start-sample)
        (dotimes (i (length start-sample))
          (setf msg
                (nconc msg
                       (list (elt start-sample i)
                             (elt num-samples i)
                             (elt val i)))))
        (setf msg (nconc msg (list start-sample num-samples val))))
    msg))

(defmethod write-event ((obj buffer-fill) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-fill (slot-value obj 'bufnum)
    (slot-value obj 'start-sample) (slot-value obj 'num-samples)
    (slot-value obj 'value))
   io))

(defmethod import-set-slots ((obj buffer-fill) lst)
  (let ((len 0))
    (setf (slot-value obj 'bufnum) (pop lst))
    (setf len (length lst))
    (if (= len 3)
        (progn (setf (slot-value obj 'start-sample) (pop lst))
               (setf (slot-value obj 'num-samples) (pop lst))
               (setf (slot-value obj 'value) (pop lst)))
        (do ((i 0 (+ i 3)))
            ((= i len))
          (setf (slot-value obj 'start-sample)
                (nconc (slot-value obj 'start-sample)
                       (list (elt lst i))))
          (setf (slot-value obj 'num-samples)
                (nconc (slot-value obj 'num-samples)
                       (list (elt lst (+ 1 i)))))
          (setf (slot-value obj 'value)
                (nconc (slot-value obj 'value)
                       (list (elt lst (+ 2 i)))))))))

(defobject buffer-close (sc-cmd) ((bufnum :initform nil))
 (:parameters bufnum) (:event-streams))

(defun buffer-close (buf-num) (list "/b_close" buf-num))

(defmethod write-event ((obj buffer-close) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time (buffer-close (slot-value obj 'bufnum)) io))

(defmethod import-set-slots ((obj buffer-close) lst)
  (setf (slot-value obj 'bufnum) (pop lst)))

(defparameter *buffer-gen-flags* (list
                                  :normalize
                                  1
                                  :wavetable
                                  2
                                  :clear
                                  4))

(defparameter *buffer-gen-commands* (list
                                     :sine1
                                     "sine1"
                                     :sine2
                                     "sine2"
                                     :sine3
                                     "sine3"
                                     :cheby
                                     "cheby"))

(defobject buffer-gen (sc-cmd)
 ((bufnum :initform nil) (command :initform nil)
  (flags :initform nil) (args :initform nil))
 (:parameters bufnum command flags args) (:event-streams))

(defun buffer-gen (bufnum command flags args)
  (append (list "/b_gen"
                bufnum
                (getf *buffer-gen-commands* command)
                (if (consp flags)
                    (do ((tail flags (cdr tail)) (bits 0))
                        ((null tail) bits)
                      (setf bits
                            (logior bits
                                    (getf
                                     *buffer-gen-flags*
                                     (car tail)))))
                    (getf *buffer-gen-flags* flags)))
          args))

(defmethod write-event ((obj buffer-gen) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (buffer-gen (slot-value obj 'bufnum) (slot-value obj 'command)
    (slot-value obj 'flags) (slot-value obj 'args))
   io))

(defmethod import-set-slots ((obj buffer-gen) lst)
  (setf (slot-value obj 'bufnum) (pop lst))
  (setf (slot-value obj 'command) (pop lst))
  (setf (slot-value obj 'flags) (pop lst))
  (setf (slot-value obj 'args) lst))

(defobject control-set (sc-cmd)
 ((bus :initform nil) (value :initform nil)) (:parameters bus value)
 (:event-streams))

(defun control-set (bus-index control-value)
  (let ((msg nil))
    (if (consp bus-index)
        (progn (setf msg (list "/c_set"))
               (dotimes (i (length bus-index))
                 (setf msg
                       (nconc msg
                              (list
                               (elt bus-index i)
                               (elt control-value i))))))
        (setf msg (list "/c_set" bus-index control-value)))
    msg))

(defmethod write-event ((obj control-set) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (control-set (slot-value obj 'bus) (slot-value obj 'value)) io))

(defmethod import-set-slots ((obj control-set) lst)
  (setf (slot-value obj 'bus) (pop lst))
  (setf (slot-value obj 'value) (pop lst)))

(defobject control-setn (sc-cmd)
 ((bus :initform nil) (value :initform nil)) (:parameters bus value)
 (:event-streams))

(defun control-setn (bus val)
  (let ((msg nil))
    (if (consp bus)
        (progn (setf msg (list "/c_setn"))
               (dotimes (i (length bus))
                 (setf msg (nconc msg (list (elt bus i))))
                 (setf msg
                       (nconc msg
                              (list
                               (if
                                (consp (elt val i))
                                (length (elt val i))
                                1))))
                 (setf msg
                       (nconc msg
                              (if
                               (consp (elt val i))
                               (elt val i)
                               (list (elt val i)))))))
        (progn (setf msg (list "/c_setn" bus (length val)))
               (setf msg
                     (nconc msg (if (consp val) val (list val))))))
    msg))

(defmethod write-event ((obj control-setn) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (control-setn (slot-value obj 'bus) (slot-value obj 'value)) io))

(defmethod import-set-slots ((obj control-setn) lst)
  (let ((len (length lst)) (num-vals 0) (s-vals nil))
    (if (= len 3)
        (progn (setf (slot-value obj 'bus) (pop lst))
               (setf num-vals (pop lst))
               (setf (slot-value obj 'value) (pop lst)))
        (do ((i 0))
            ((= i len))
          (setf s-vals nil)
          (setf (slot-value obj 'bus)
                (nconc (slot-value obj 'bus) (list (elt lst i))))
          (setf num-vals (elt lst (incf i)))
          (dotimes (j num-vals)
            (setf s-vals (nconc s-vals (list (elt lst (incf i))))))
          (setf (slot-value obj 'value)
                (nconc (slot-value obj 'value) (list s-vals)))
          (incf i)))))

(defobject control-fill (sc-cmd)
 ((bus :initform nil) (num-buses :initform nil)
  (value :initform nil))
 (:parameters bus num-buses value) (:event-streams))

(defun control-fill (bus-index num-buses val)
  (let ((msg nil))
    (if (consp bus-index)
        (progn (setf msg (list "/c_fill"))
               (dotimes (i (length bus-index))
                 (setf msg
                       (nconc msg
                              (list
                               (elt bus-index i)
                               (elt num-buses i)
                               (coerce
                                (elt val i)
                                'single-float))))))
        (setf msg
              (list "/c_fill"
                    bus-index
                    num-buses
                    (coerce val 'single-float))))
    msg))

(defmethod write-event ((obj control-fill) (io sc-file) time)
  (setf (object-time io) time)
  (write-bundle time
   (control-fill (slot-value obj 'bus) (slot-value obj 'num-buses)
    (slot-value obj 'value))
   io))

(defmethod import-set-slots ((obj control-fill) lst)
  (let ((len (length lst)))
    (if (= len 3)
        (progn (setf (slot-value obj 'bus) (pop lst))
               (setf (slot-value obj 'num-buses) (pop lst))
               (setf (slot-value obj 'value) (pop lst)))
        (do ((i 0 (+ i 3)))
            ((= i len))
          (setf (slot-value obj 'bus)
                (nconc (slot-value obj 'bus) (list (elt lst i))))
          (setf (slot-value obj 'num-samples)
                (nconc (slot-value obj 'num-buses)
                       (list (elt lst (+ 1 i)))))
          (setf (slot-value obj 'value)
                (nconc (slot-value obj 'value)
                       (list (elt lst (+ 2 i)))))))))

(defparameter *sc-env-curves* (list
                               :step
                               0
                               :linear
                               1
                               :lin
                               1
                               :exp
                               2
                               :exponential
                               2
                               :sine
                               3
                               :welch
                               4))

(defobject sc-env ()
 ((envelope :initform nil) (curve :initform :linear)
  (duration :initform nil) (scale :initform 1.0) (offset :initform 0)
  (release-node :initform nil) (loop-node :initform nil))
 (:parameters envelope duration scale offset release-node loop-node))

(defmethod sc-env->list ((obj sc-env))
  (let* ((env (slot-value obj 'envelope))
         (curves (slot-value obj 'curve))
         (len (length env))
         (sc-env-list (list))
         (levels (list))
         (times (list))
         (full-time nil)
         (curve-num-list (list))
         (time-scale nil)
         (prev-time 0)
         (curve-list (list)))
    (if (not (slot-value obj 'release-node))
        (setf (slot-value obj 'release-node) -99))
    (if (not (slot-value obj 'loop-node))
        (setf (slot-value obj 'loop-node) -99))
    (do ((i 0 (+ i 2)))
        ((= i len))
      (setf times (nconc times (list (- (elt env i) prev-time))))
      (setf levels (nconc levels (list (elt env (+ 1 i)))))
      (setf prev-time (elt env i)))
    (pop times)
    (setf full-time (apply #'+ times))
    (setf time-scale
          (coerce (/ (slot-value obj 'duration) full-time)
                  'single-float))
    (dotimes (i (length times))
      (setf (elt times i) (* (elt times i) time-scale)))
    (dotimes (i (length levels))
      (setf (elt levels i)
            (+ (slot-value obj 'offset)
               (* (elt levels i) (slot-value obj 'scale)))))
    (cond ((numberp curves)
           (dotimes (i (length times))
             (setf curve-num-list
                   (nconc curve-num-list (list curves)))
             (setf curve-list (nconc curve-list (list 5)))))
          ((keyword? curves)
           (dotimes (i (length times))
             (setf curve-list
                   (nconc curve-list
                          (list (getf *sc-env-curves* curves))))
             (setf curve-num-list (nconc curve-num-list (list 0)))))
          ((listp curves)
           (dotimes (i (length times))
             (if (keyword? (elt curves i))
                 (progn (setf curve-list
                              (nconc
                               curve-list
                               (list
                                (getf
                                 *sc-env-curves*
                                 (elt curves i)))))
                        (setf curve-num-list
                              (nconc curve-num-list (list 0))))
                 (progn (setf curve-num-list
                              (nconc
                               curve-num-list
                               (list (elt curves i))))
                        (setf curve-list
                              (nconc curve-list (list 5))))))))
    (setf sc-env-list
          (list (pop levels)
                (length times)
                (slot-value obj 'release-node)
                (slot-value obj 'loop-node)))
    (dotimes (i (length times))
      (setf sc-env-list
            (nconc sc-env-list
                   (list (pop levels)
                         (pop times)
                         (pop curve-list)
                         (pop curve-num-list)))))
    sc-env-list))

(defobject sc-buffer (sc-cmd)
 ((bufnum :initform nil) (with-file :initform nil)
  (with-values :initform nil) (with-gen :initform nil)
  (starting-at :initform 0) (frames :initform -1)
  (channels :initform 1))
 (:parameters bufnum with-file with-values with-gen starting-at
  frames channels time))

(defmethod write-event ((obj sc-buffer) (io sc-file) time)
  (cond ((slot-value obj 'with-file)
         (write-event
          (make-instance
            <buffer-alloc-read>
            :bufnum
            (slot-value obj 'bufnum)
            :file
            (slot-value obj 'with-file)
            :frames
            (slot-value obj 'frames)
            :start-frame
            (slot-value obj 'starting-at))
          io time))
        ((listp (slot-value obj 'with-values))
         (write-event
          (make-instance
            <buffer-alloc>
            :bufnum
            (slot-value obj 'bufnum)
            :frames
            (slot-value obj 'frames)
            :channels
            1)
          io time)
         (write-event
          (make-instance
            <buffer-setn>
            :bufnum
            (slot-value obj 'bufnum)
            :samples-values
            (list (slot-value obj 'starting-at)
                  (slot-value obj 'with-values)))
          io time))
        ((numberp (slot-value obj 'with-values))
         (write-event
          (make-instance
            <buffer-alloc>
            :bufnum
            (slot-value obj 'bufnum)
            :frames
            (slot-value obj 'frames)
            :channels
            1)
          io time)
         (write-event
          (make-instance
            <buffer-fill>
            :bufnum
            (slot-value obj 'bufnum)
            :num-samples
            (- (slot-value obj 'frames)
               (slot-value obj 'starting-at))
            :value
            (slot-value obj 'with-values))
          io time))
        ((functionp (slot-value obj 'with-values))
         (let ((vals '()))
           (dotimes (i
                     (- (slot-value obj 'frames)
                        (slot-value obj 'starting-at)))
             (setf vals
                   (nconc vals
                          (list (apply
                                 (slot-value obj 'with-values)
                                 '())))))
           (write-event
            (make-instance
              <buffer-alloc>
              :bufnum
              (slot-value obj 'bufnum)
              :frames
              (slot-value obj 'frames)
              :channels
              1)
            io time)
           (write-event
            (make-instance
              <buffer-setn>
              :bufnum
              (slot-value obj 'bufnum)
              :samples-values
              (list (slot-value obj 'starting-at) vals))
            io time)))
        ((slot-value obj 'with-gen)
         (write-event
          (make-instance
            <buffer-alloc>
            :bufnum
            (slot-value obj 'bufnum)
            :frames
            (slot-value obj 'frames)
            :channels
            1)
          io time)
         (write-event
          (make-instance
            <buffer-gen>
            :bufnum
            (slot-value obj 'bufnum)
            :flags
            :wavetable
            :command
            (car (slot-value obj 'with-gen))
            :args
            (car (cdr (slot-value obj 'with-gen))))
          io time))))

(progn (defclass scsynth (event)
         ((node :initform -1 :initarg :node)
          (add-action :initform 0 :initarg :add-action)
          (target :initform 1 :initarg :target)))
       (defparameter <scsynth> (find-class 'scsynth))
       (finalize-class <scsynth>)
       (values))

(defmethod write-event ((obj scsynth) (io sc-file) time)
  (let* ((node-set-list '())
         (synthname (symbol-name (class-name (class-of obj))))
         (slots (instance-slots obj))
         (inits (list nil)))
    (setf (object-time io) time)
    (write-bundle time
     (list* "/s_new"
            (string-downcase synthname)
            (slot-value obj 'node)
            (slot-value obj 'add-action)
            (slot-value obj 'target)
            (do ((tail slots (cdr tail)) (args inits))
                ((null tail) (cdr inits))
              (unless (member (car tail)
                              '(node add-action target time))
                (cond ((listp (slot-value obj (car tail)))
                       (progn (setf
                               node-set-list
                               (nconc
                                node-set-list
                                (list (symbol->keyword (car tail)))))
                              (setf
                               node-set-list
                               (nconc
                                node-set-list
                                (list
                                 (slot-value obj (car tail)))))))
                      ((equal (find-class 'sc-env)
                              (class-of (slot-value obj (car tail))))
                       (setf node-set-list
                             (nconc
                              node-set-list
                              (list (symbol->keyword (car tail)))))
                       (setf node-set-list
                             (nconc
                              node-set-list
                              (list
                               (sc-env->list
                                (slot-value obj (car tail)))))))
                      (t
                       (rplacd args
                               (list
                                (string-downcase
                                 (symbol-name (car tail)))
                                (slot-value obj (car tail))))
                       (setf args (cddr args)))))))
     io)
    (when node-set-list
      (write-event
       (make-instance
         <node-setn>
         :node
         (slot-value obj 'node)
         :controls-values
         node-set-list)
       io time))))

(defmethod import-set-slots ((obj scsynth) lst)
  (setf (slot-value obj 'node) (pop lst))
  (setf (slot-value obj 'add-action) (pop lst))
  (setf (slot-value obj 'target) (pop lst))
  (let ((len (length lst)))
    (do ((i 0 (+ i 2)))
        ((= i len))
      (setf (slot-value obj (intern (string-upcase (elt lst i)) :cm))
            (elt lst (+ 1 i))))))

(defparameter *sc-command-object-mappings* (list
                                            "/d_load"
                                            'load-synthdef
                                            "/d_loadDir"
                                            'load-synthdef-dir
                                            "/n_free"
                                            'node-free
                                            "/n_set"
                                            'node-set
                                            "/n_setn"
                                            'node-setn
                                            "/n_map"
                                            'node-map
                                            "/n_before"
                                            'node-before
                                            "/n_after"
                                            'node-after
                                            "/g_new"
                                            'group-new
                                            "/g_head"
                                            'group-head
                                            "/g_tail"
                                            'group-tail
                                            "/g_freeAll"
                                            'group-free-all
                                            "/g_deepFree"
                                            'group-deep-free
                                            "/u_cmd"
                                            'ugen-command
                                            "/b_alloc"
                                            'buffer-alloc
                                            "/b_allocRead"
                                            'buffer-alloc-read
                                            "/b_read"
                                            'buffer-read
                                            "/b_write"
                                            'buffer-write
                                            "/b_free"
                                            'buffer-free
                                            "/b_zero"
                                            'buffer-zero
                                            "/b_set"
                                            'buffer-set
                                            "/b_setn"
                                            'buffer-setn
                                            "/b_fill"
                                            'buffer-fill
                                            "/b_close"
                                            'buffer-close
                                            "/b_gen"
                                            'buffer-gen
                                            "/b_get"
                                            'buffer-get
                                            "/b_getn"
                                            'buffer-getn
                                            "/c_set"
                                            'control-set
                                            "/c_setn"
                                            'control-setn
                                            "/c_fill"
                                            'control-fill))

(defun return-sc-class-symbol (strg)
  (do ((tail *sc-command-object-mappings* (cddr tail)) (clas nil))
      ((or (null tail) clas) clas)
    (if (string= strg (car tail)) (setf clas (cadr tail)))))

(defun collect-type-list (vec)
  (let ((l (u8vector-length vec)) (h '()))
    (do ((i 0 (+ i 1)) (j nil))
        ((or (= i l) (equal j 0)))
      (setf j (u8vector-ref vec i))
      (unless (= j 0) (setf h (nconc h (list (code-char j))))))
    h))

(defun parse-osc-vec (vec func)
  (let ((cmd nil)
        (pos 0)
        (timestamp nil)
        (typelist nil)
        (cmd-args nil))
    (unless (string= (u8vector->string (u8vector-subseq vec 0 7))
                     "#bundle")
      (error "this does not appear to be a properly formatted .osc file"))
    (setf timestamp (u8vector->uint (u8vector-subseq vec 8 12)))
    (setf timestamp
          (+ timestamp
             (coerce (/ (u8vector->uint (u8vector-subseq vec 12 16))
                        4294967295)
                     'single-float)))
    (setf cmd (u8vector->string (u8vector-subseq vec 20)))
    (setf pos (+ 20 (length cmd)))
    (setf pos (+ pos (- 4 (mod pos 4))))
    (setf typelist (collect-type-list (u8vector-subseq vec pos)))
    (setf pos (+ (length typelist) pos))
    (setf pos (+ pos (- 4 (mod pos 4))))
    (setf cmd-args
          (loop for i in (rest typelist)
                with x = 0
                do (cond ((char= i #\s)
                          (setf x
                                (u8vector->string
                                 (u8vector-subseq vec pos)))
                          (incf pos
                                (+
                                 (length x)
                                 (- 4 (mod (length x) 4)))))
                         ((char= i #\i)
                          (setf x
                                (u8vector->int
                                 (u8vector-subseq
                                  vec
                                  pos
                                  (incf pos 4)))))
                         ((char= i #\f)
                          (setf x
                                (u8vector->float
                                 (u8vector-subseq
                                  vec
                                  pos
                                  (incf pos 4))))))
                collect x))
          (funcall func timestamp cmd cmd-args)))

(defun bundle->object (timestamp cmd cmd-args)
  (let ((obj nil))
    (cond ((equal cmd "/s_new")
           (setf obj
                 (make-instance
                   (find-class (intern
                                (string-upcase (first cmd-args))
                                :cm))
                   :time
                   timestamp))
           (import-set-slots obj (rest cmd-args)))
          (t
           (let ((class-symbol (return-sc-class-symbol cmd)))
             (if class-symbol
                 (progn (setf obj
                              (make-instance
                               (find-class class-symbol)
                               :time
                               timestamp))
                        (import-set-slots obj cmd-args))))))
    obj))

(defun sc-read-bytes (str num)
  (do ((v (make-u8vector num)) (j 0 (+ j 1)) (b nil))
      ((or (not v) (= j num)) v)
    (setf b (file-byte str))
    (if (file-eof? b) (setf v nil) (u8vector-set! v j b))))

(defmethod import-events ((file sc-file) &rest args)
  args
  (with-open-io (obj file :input)
   (do ((str (io-open obj)) (seq (list)) (len 0) (mess nil))
       ((not len)
        (make-instance <seq> :subobjects (nreverse (cddr seq))))
     (setf len (sc-read-bytes str 4))
     (when len
       (setf len (u8vector->int len))
       (setf mess (sc-read-bytes str len)))
     (push (parse-osc-vec mess #'bundle->object) seq))))

(defun dumposc (file &rest args)
  (let ((out (if (null args) t (car args))) (fil nil))
    (unwind-protect
        (progn (setf fil (open-file file ':input ':byte))
               (when fil
                 (format out "~%[")
                 (do ((len 0) (one nil) (vec nil))
                     ((not len) nil)
                   (setf len (sc-read-bytes fil 4))
                   (when len
                     (setf len (u8vector->int len))
                     (setf vec (sc-read-bytes fil len)))
                   (parse-osc-vec vec
                    (lambda (time cmd args)
                      (format out (if one ",~%" "~%"))
                      (format out "[~s" time)
                      (format out ", [~s" cmd)
                      (dolist (c args)
                        (if (floatp c)
                            (format out ", ~F" c)
                            (format out ", ~s" c)))
                      (format out "]]")
                      (setf one t))))
                 (format out "~%]~%")))
      (when fil (close-file fil ':input)))
    (if fil out nil)))
