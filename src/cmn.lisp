;;; **********************************************************************
;;; Copyright (C) 2009 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from cmn.scm on 04-Aug-2009 14:11:46

(in-package :cm)

(progn (defclass cmn-file (event-file)
         ((exact :initform nil :initarg :exact-rhythms)
          (staffing :initform '() :accessor cmn-staffing :initarg
           :staffing))
         #+metaclasses
         (:metaclass io-class))
       (defparameter <cmn-file> (find-class 'cmn-file))
       (finalize-class <cmn-file>)
       (setf (io-class-file-types <cmn-file>) '("*.cmn" "*.eps"))
       (values))

(defun set-cmn-output-hook! (fn)
  (unless (or (not fn) (functionp fn))
    (error "Not a cmn output hook: ~s" fn))
  (setf (io-class-output-hook <cmn-file>) fn)
  (values))

(defparameter *cmn-staves* (make-hash-table :size 31 :test #'equal))

(defun make-staffing (id &key name clef meter)
  (list id nil (or name (format nil "staff-~a" id)) clef meter))

(defmethod close-io ((io cmn-file) &rest mode)
  mode
  (setf (io-open io) nil))

(defmethod open-io ((io cmn-file) dir &rest args)
  args
  (when (eq dir ':output)
    (setf (io-open io)
          (init-clm-input
           (apply #'make-instance
                  (find-class 'score)
                  :output-file
                  (file-output-filename io)
                  (event-stream-args io))))
    (setf *exact-rhythms* (slot-value io 'exact)))
  io)

(defmethod initialize-io ((io cmn-file))
  (let ((score (io-open io)))
    (clrhash *cmn-staves*)
    (loop for s in (cmn-staffing io)
          for c = (apply #'make-staffing s)
          do (rplaca (cdr c) (add-staff score (third c) '()))
             (setf (gethash (first c) *cmn-staves*) c))
          (values)))

(defun set-one-staff-meter (staff meter)
  (let ((stfd
         (find-if (lambda (x) (eq staff (stfdat-staff x)))
                  staff-descriptors)))
    (setf (staff-data (stfdat-staff stfd))
          (append (staff-data (stfdat-staff stfd))
                  (list (cmn-eval meter))))))

(defmethod deinitialize-io ((io cmn-file))
  (flet ((get-active-staff-actions (score)
           score
           (let ((ids
                  (sort (hash-fold (lambda (k v p) v (cons k p)) '()
                         *cmn-staves*)
                        #'<))
                 (data '()))
             (dolist (id ids)
               (let* ((desc (gethash id *cmn-staves*))
                      (staff (second desc))
                      (label (third desc))
                      (clefs (fourth desc))
                      (meter (elt desc 4))
                      (count nil))
                 (when (staff-data staff)
                   (if (not (listp clefs)) (setf clefs (list clefs)))
                   (setf meter (elt desc 4))
                   (setf count (if (member ':both clefs) 2 1))
                   (push (list 'set-staff-number label count) data)
                   (when clefs
                     (push (list* 'set-staff-clef label clefs) data))
                   (when meter
                     (if (consp meter)
                         (unless (eq (first meter) 'meter)
                           (push 'meter meter))
                         (error "meter should be list like: (meter 3 4)"))
                     (push (list 'set-one-staff-meter label meter)
                           data)))))
             (nreverse data))))
    (let* ((score (io-open io))
           (path (file-output-filename io))
           (type (if (string= (filename-type path) "cmn") :cmn nil))
           (args '()))
      (unless (eq type ':cmn)
        (format t "~%Manuscripting ~a..." path))
      (setf args (get-active-staff-actions score))
      (apply #'finish-clm-input score type nil args))))

(defun cmn-eval (form)
  (flet ((cmnfun (sym)
           (let ((fun (find-symbol (symbol-name sym) :cmn)))
             (unless (and fun (fboundp fun))
               (error "~S is not a cmn function!" sym))
             fun))
         (cmnvar (sym)
           (let ((var (find-symbol (symbol-name sym) :cmn)))
             (unless (and var (boundp var))
               (error "~S is not a cmn variable." sym))
             (symbol-value var))))
    (cond ((consp form)
           (apply (cmnfun (car form))
                  (mapcar #'cmn-eval (cdr form))))
          ((constantp form) form)
          (form (cmnvar form))
          (t nil))))

(defun add-default-staff (id score)
  (let* ((entry (make-staffing id))
         (sname (third entry))
         (staff
          (or (find-staff score sname) (add-staff score sname '()))))
    (rplaca (cdr entry) staff)
    entry))

(defmethod write-event ((obj standard-object) (io cmn-file)
                        scoretime)
  (let ((score (io-open io))
        (data (object->cmn obj))
        (entry nil)
        (staff nil))
    (unless (consp data)
      (error "object->cmn did not return a list: ~s.:" data))
    (setf entry (gethash (first data) *cmn-staves*))
    (unless entry
      (setf entry (add-default-staff (first data) score)))
    (setf staff (second entry))
    (if (= (length data) 2)
        (add-data-1 score staff (cmn-eval (second data)))
        (let ((dur (second data))
              (note (third data))
              (args
               (loop for i in (cdddr data) collect (cmn-eval i))))
              (unless (rest? note)
                (apply #'add-note-to-staff
                       score
                       staff
                       scoretime
                       dur
                       (cmn-eval note)
                       args))))))

(defobject cmn (event)
 ((staff :initform 0) (expr :initform nil :initarg :note)
  (duration :initform nil) (data :initform 'nil)))

(defmethod initialize-instance :after ((obj cmn)
                                       &rest
                                       args) args (do
                                                   ((a
                                                     args
                                                     (cddr a)))
                                                   ((null a) nil)
                                                   (case
                                                    (car a)
                                                    ((:note)
                                                     (setf
                                                      (cmn-expr obj)
                                                      (cadr a)))
                                                    ((:expr)
                                                     (setf
                                                      (cmn-expr obj)
                                                      (cadr a))))))

(defmethod object->cmn ((obj cmn))
  (let ((d (cmn-duration obj)))
    (if d
        (let ((n
               (or (note (cmn-expr obj) :in? *chromatic-scale*)
                   (error "cmn: '~s' is not a note for duration ~s."
                          (cmn-expr obj)
                          d))))
          (list* (cmn-staff obj)
                 d
                 n
                 (let ((x (cmn-data obj)))
                   (unless (listp x)
                     (error "cmn data '~s' is not a list." x))
                   x)))
        (list (cmn-staff obj)
              (let ((e (cmn-expr obj)) (x (cmn-data obj)))
                (if e
                    (if x
                        (progn (unless
                                (listp x)
                                (error
                                 "cmn data '~s' is not a list."
                                 x))
                               `(engorge (list ,e ,@x)))
                        e)
                    (if x
                        `(engorge (list ,@x))
                        (error "cmn: missing :expr, :note or :data"))))))))

(defmethod object->midi ((obj cmn))
  (let ((e (cmn-expr obj))
        (b (object-time obj))
        (d (cmn-duration obj)))
    (if d
        (make-instance
          <midi>
          :time
          b
          :duration
          d
          :channel
          (cmn-staff obj)
          :keynum
          e)
        (if (consp e)
            (case (car e)
              ((mm)
               (make-instance
                 <midi-tempo-change>
                 :time
                 b
                 :usecs
                 (floor (* (/ 60 (cadr e)) 1000000))))
              ((meter)
               (make-instance
                 <midi-time-signature>
                 :time
                 b
                 :numerator
                 (cadr e)
                 :denominator
                 (caddr e)))
              (t nil))
            (let* ((l
                    '((cf-major af-minor) (gf-major ef-minor)
                      (df-major bf-minor) (af-major f-minor)
                      (ef-major c-minor) (bf-major g-minor)
                      (f-major d-minor) (c-major a-minor)
                      (g-major e-minor) (d-major b-minor)
                      (a-major fs-minor) (e-major cs-minor)
                      (b-major gs-minor) (fs-major ds-minor)
                      (cs-major as-minor)))
                   (p (position-if (lambda (x) (member e x)) l)))
              (if p
                  (make-instance
                    <midi-key-signature>
                    :time
                    b
                    :key
                    (- p 7)
                    :mode
                    (position-if (lambda (x) (eq e x)) (elt l p)))
                  nil))))))

(defmethod object->cmn ((obj midi))
  (list (midi-channel obj)
        (midi-duration obj)
        (note (midi-keynum obj))))
