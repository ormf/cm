;;; **********************************************************************
;;; Copyright (C) 2009 Heinrich Taube, <taube (at) uiuc (dot) edu>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the Lisp Lesser Gnu Public License.
;;; See http://www.cliki.net/LLGPL for the text of this agreement.
;;; **********************************************************************

;;; generated by scheme->cltl from clm.scm on 04-Aug-2009 14:11:46

(in-package :cm)

(defun clm-print-par-value (v s)
  (when (consp v) (write-char #\' s))
  (write v :stream s))

(defun clm-par-print (par objv filv timv)
  (let* ((raw
          (if (parameter-time? par)
              timv
              (slot-getter-form objv (parameter-slot par))))
         (acc
          (if (parameter-decimals par)
              `(decimals ,raw ,(parameter-decimals par))
              raw))
         (delim #\ ))
    (case (parameter-type par)
      ((required)
       `(progn (write-char ,delim ,filv)
               (clm-print-par-value ,acc ,filv)))
      ((optional)
       (let ((form `(clm-print-par-value ,acc ,filv)))
         `(if (slot-boundp ,objv ',(parameter-slot par))
              (progn (write-char ,delim ,filv) ,form))))
      ((key)
       `(if (slot-boundp ,objv ',(parameter-slot par))
            (progn (write-char ,delim ,filv)
                   (write ',(parameter-prefix par) :stream ,filv)
                   (write-char ,delim ,filv)
                   (clm-print-par-value ,acc ,filv))))
      ((rest)
       (let ((v (gensym)))
         `(if (slot-boundp ,objv ',(parameter-slot par))
              (do ((,v ,(slot-getter-form objv (parameter-slot par))
                    (cdr ,v)))
                  ((null ,v) nil)
                (write-char ,delim ,filv)
                (write (car ,v) :stream ,filv))))))))

(defun clm-writer (objclassname objclassvar pars supers sdecl)
  supers
  sdecl
  (define-output-method objclassname objclassvar 'obj 'clm-file
   '<clm-file> 'io 'scoretime
   (list `(let ((fp (io-open io)))
            (write-char #\( fp)
            (princ (object-name obj) fp)
            ,@(mapcar (lambda (p)
                        (clm-par-print p 'obj 'fp 'scoretime))
                      pars)
            (write-char #\) fp)
            (terpri fp)
            (values)))))

(progn (defclass clm-file (event-file)
         nil
         #+metaclasses
         (:metaclass io-class))
       (defparameter <clm-file> (find-class 'clm-file))
       (finalize-class <clm-file>)
       (setf (io-class-definer <clm-file>) #'clm-writer)
       (setf (io-class-file-types <clm-file>) '("*.clm"))
       (values))

(defun set-clm-output-hook! (fn)
  (unless (or (not fn) (functionp fn))
    (error "Not a clm output hook: ~s" fn))
  (setf (io-class-output-hook <clm-file>) fn)
  (values))

(defmethod initialize-io ((io clm-file))
  (when (eq (io-direction io) ':output)
    (format (io-open io)
            ";;; ~a output on ~a~%"
            (cm-version)
            (date-and-time))))

(defun play-clm-file (file &rest args)
  (let ((verbose (getf args :verbose t))
        (output (getf args ':output)))
    (if (not output) (setf output *clm-file-name*))
    (if verbose (apply #'tell-snd output args))
    (apply #'clm-load file args)))

(set-clm-output-hook! #'play-clm-file)

(defun snd-writer (objclassname objclassvar pars supers sdecl)
  supers
  sdecl
  (flet ((parf (par objv argsv timv)
           (let* ((raw
                   (if (parameter-time? par)
                       timv
                       (slot-getter-form objv (parameter-slot par))))
                  (acc
                   (if (parameter-decimals par)
                       `(decimals ,raw ,(parameter-decimals par))
                       raw)))
             (case (parameter-type par)
               ((required)
                `(progn (rplacd ,argsv (list ,acc))
                        (setf ,argsv (cdr ,argsv))))
               ((optional)
                `(if (slot-boundp ,objv ',(parameter-slot par))
                     (progn (rplacd ,argsv (list ,acc))
                            (setf ,argsv (cdr ,argsv)))))
               ((key)
                `(if (slot-boundp ,objv ',(parameter-slot par))
                     (progn (rplacd ,argsv
                                    (list ',(parameter-prefix par)))
                            (setf ,argsv (cdr ,argsv))
                            (rplacd ,argsv (list ,acc))
                            (setf ,argsv (cdr ,argsv)))))
               ((rest)
                `(if (slot-boundp ,objv ',(parameter-slot par))
                     (progn (rplacd ,argsv ,acc)
                            (setf ,argsv (cdr ,argsv)))))))))
    (define-output-method objclassname objclassvar 'obj 'audio-file
     '<audio-file> 'io 'scoretime
     (list `(let* ((args (list nil)) (tail args))
              (if (eq (slot-value io 'output-trace) t)
                  (format t
                          "~a ~s..."
                          (object-name obj)
                          (decimals scoretime 3)))
              ,@(mapcar (lambda (p) (parf p 'obj 'tail 'scoretime))
                        pars)
              (apply #',objclassname (cdr args))
              (values))))))

(progn (defclass audio-file (event-file)
         ((output-trace :initform :info :initarg :trace-output
           :accessor audio-file-output-trace))
         #+metaclasses
         (:metaclass io-class))
       (defparameter <audio-file> (find-class 'audio-file))
       (finalize-class <audio-file>)
       (setf (io-class-definer <audio-file>) #'snd-writer)
       (setf (io-class-file-types <audio-file>)
             '("*.snd" "*.aiff" "*.aif" "*.wav"))
       (values))

(defun set-audio-output-hook! (fn)
  (unless (or (not fn) (functionp fn))
    (error "Not an audio output hook: ~s" fn))
  (setf (io-class-output-hook <audio-file>) fn)
  (values))

(defparameter *audio-player* (cond-expand
                              (common-lisp
                               (let
                                ((os (os-name)))
                                (cond
                                 ((member
                                   os
                                   '(unix cygwin linux darwin))
                                  (cond
                                   ((probe-file
                                     "/usr/local/bin/sndplay")
                                    "/usr/local/bin/sndplay")
                                   ((probe-file "/usr/bin/sndplay")
                                    "/usr/bin/sndplay")
                                   ((probe-file
                                     "/usr/local/bin/qtplay")
                                    "/usr/local/bin/qtplay")
                                   ((probe-file "/usr/bin/qtplay")
                                    "/usr/bin/qtplay")
                                   ((member os '(darwin osx maxosx))
                                    "open")
                                   (t nil)))
                                 ((member os '(win32))
                                  (if
                                   (probe-file
                                    "/Program Files/Windows Media Player/mplayer2.exe")
                                   "\\Program Files\\Windows Media Player\\mplayer2.exe"))
                                 (t nil))))
                              (else
                               (let
                                ((os (os-name)))
                                (if
                                 (member
                                  (os-name)
                                  '(unix cygwin linux darwin))
                                 (cond
                                  ((probe-file
                                    "/usr/local/bin/sndplay")
                                   "/usr/local/bin/sndplay")
                                  ((probe-file "/usr/bin/sndplay")
                                   "/usr/bin/sndplay")
                                  ((probe-file
                                    "/usr/local/bin/qtplay")
                                   "/usr/local/bin/qtplay")
                                  ((probe-file "/usr/bin/qtplay")
                                   "/usr/bin/qtplay")
                                  ((member os '(darwin osx maxosx))
                                   "open")
                                  (t nil))
                                 nil)))))

(defun play-audio-file (file &rest args)
  (if (getf args ':play t)
      (cond-expand
       (clm
        (funcall #'dac
                 file
                 :start
                 (getf args ':start)
                 :end
                 (getf args ':end)
                 :wait
                 (getf args ':wait)))
       (else
        (let ((cmd *audio-player*)
              (tyo (getf args ':verbose))
              (wai (getf args ':wait)))
          (setf cmd (concatenate 'string cmd " " file))
          (if tyo (format t "~%; ~a" cmd))
          (shell cmd :wait wai :output nil)
          file)))
      nil))

(set-audio-output-hook! #'play-audio-file)

(defun formals->defobject (form &optional tpar)
  (let* ((&keys '(&optional &rest &key &aux &allow-other-keys))
         (name (pop form))
         (pars
          (mapcar (lambda (x)
                    (case x
                      ((:optional) '&optional)
                      ((:rest) '&rest)
                      ((:key) '&key)
                      ((:aux) '&aux)
                      ((:allow-other-keys) '&allow-other-keys)
                      (t (if (consp x) (car x) x))))
                  form))
         (slots '()))
    (do ((tail pars (cdr tail)))
        ((null tail) (setf slots (reverse slots)))
      (unless (member (car tail) &keys)
        (if (or (and tpar (equal (car tail) tpar))
                (member (car tail) *time-slots*))
            (push (list (car tail) :accessor 'object-time) slots)
            (push (car tail) slots))))
    `(defobject ,name () ,slots (:parameters ,@pars)
      (:event-streams clm-file audio-file))))

(defparameter *clm-imports* (list))

(defparameter *clm-import-translations* (quote
                                         ((let import-let)
                                          (let* import-let)
                                          (progn import-progn)
                                          (clm:with-sound
                                           import-with-sound)
                                          (defun import-defun))))

(defun import-form (form translate exclude include &optional
                    toplevel?)
  (let ((sym (car form)))
    (if (or (not (and sym (symbolp sym)))
            (and toplevel? (member sym exclude)))
        nil
        (let* ((obj (find-class sym nil))
               (pars (and obj (class-parameters obj))))
          (if pars
              (import-object pars form)
              (let ((trans (assoc sym translate)))
                (if trans
                    (funcall (cadr trans)
                             form
                             translate
                             exclude
                             include)
                    (if (or (fboundp sym) (special-operator-p sym))
                        form
                        (if (and include
                                 (or
                                  (eq include t)
                                  (member sym include)))
                            form
                            (progn (format
                                    t
                                    "~%Skipping undefined function: ~s."
                                    sym)
                                   nil))))))))))

(defun import-let (form translate exclude include)
  (let ((body
         (loop for f in (cddr form)
               for r = (import-form f translate exclude include)
               when r collect r)))
         (if body (list* (car form) (cadr form) body) nil)))

(defun import-progn (form translate exclude include)
  (let ((body
         (loop for f in (cdr form)
               for r = (import-form f translate exclude include t)
               when r collect r)))
         (if body `(progn ,@body) nil)))

(defun import-with-sound (form translate exclude include)
  (values (loop for f in (cddr form)
                for r = (import-form f translate exclude include t)
                when r collect r) t))

(defun import-defun (form trans excl inc)
  (list* 'defun
         (cadr form)
         (caddr form)
         (loop for f in (cdddr form)
               collect (import-form f trans excl inc))))

(defun import-object (pars forms)
  (let ((save forms)
        (name (pop forms))
        (reqs nil)
        (opts nil)
        (rest nil)
        (keys nil))
    (setf reqs
          (loop with par
                while (and (not (null forms))
                           (eq (parameter-type (car pars))
                               'required))
                do (setf par (pop pars))
                collect (parameter-slot par)
                collect (pop forms)))
          (setf opts
                (loop with par
                      while (and (not (null forms))
                                 (eq
                                  (parameter-type (car pars))
                                  'optional))
                      do (setf par (pop pars))
                      collect (parameter-slot par)
                      collect (pop forms)))
                (when (and (not (null forms))
                           (eq (parameter-type (car pars)) 'rest))
                  (setf rest forms)
                  (pop pars))
                (setf keys
                      (loop with par
                            while (not (null forms))
                            do (setf
                                par
                                (find-if
                                 (lambda
                                  (x)
                                  (eq
                                   (car forms)
                                   (parameter-prefix x)))
                                 pars))
                               (or
                                par
                                (error
                                 "No slot for ~s in ~s."
                                 (car forms)
                                 save))
                            collect (parameter-slot par)
                            collect (cadr forms)
                            do (setf forms (cddr forms))))
                      `(push (new ,name ,@reqs ,@opts ,@rest ,@keys)
                             *clm-imports*)))

(defmethod import-events ((io clm-file) &key (output nil)
                          (translations *clm-import-translations*)
                          (include nil) (exclude nil) (seq t))
  (flet ((fprint (f s) (format s "~S~%" f)))
    (let* ((clmname (io-filename io))
           (seqname (format nil "from-~a" (filename-name clmname)))
           (*print-case* ':downcase)
           (outfil nil))
      (unless output
        (setf output
              (concatenate 'string
                           (filename-directory clmname)
                           (filename-name clmname)
                           ".cm")))
      (unless (or (eq include t) (listp include))
        (error ":include value not ~s or list: ~s" t include))
      (unless (listp exclude)
        (error ":exclude value not list: ~s." exclude))
      (setf outfil (open-file output :output))
      (with-open-io (infil io :input) (setf infil (io-open io))
       (format outfil
               ";;; Imported from ~s on ~a~%"
               clmname
               (date-and-time))
       (fprint `(setf *clm-imports* (list)) outfil)
       (loop with trans
             and flag
             for form = (file-form infil)
             until (file-eof? form)
             when (and (consp form)
                       (let ((t13 (car form)))
                         (and t13 (symbolp t13))))
               do (unless (eq include t)
                    (when (member (car form)
                                  '(defun
                                    define
                                    defmacro
                                    define-macro))
                      (unless (member (cadr form) exclude)
                        (unless (member (cadr form) include)
                          (push (cadr form) include)))))
                  (multiple-value-setq (trans flag)
                    (import-form form translations exclude include
                     t))
                  (when trans
                    (if flag
                        (dolist (x trans) (fprint x outfil))
                        (fprint trans outfil))))
               (if seq
                   (fprint
                    `(setf *clm-imports*
                           (new seq :name
                            ,(if (eq seq t) seqname `',seq)
                            :subobjects (nreverse *clm-imports*)))
                    outfil)
                   (fprint
                    `(setf *clm-imports* (nreverse *clm-imports*))
                    outfil)))
             (close-file outfil ':output)
             (setf *clm-imports* (list))
             (load output)
             *clm-imports*)))

(defun tell-snd (file &key reverb decay-time reverb-data
                 (channels *clm-channels*) (srate *clm-srate*)
                 &allow-other-keys)
  (format t "~%; File: ~s" file)
  (format t "~%; Channels: ~s" channels)
  (format t "~%; Srate: ~s" srate)
  (format t "~%; Reverb: ~a~%" (or reverb "None"))
  (if decay-time (format t "decay time: ~s%" decay-time))
  (if reverb-data (format t "reverb data: ~s~%" reverb-data))
  (values))

(defmethod open-io ((io audio-file) dir &rest args)
  args
  (if (eq dir ':output)
      (let ((inits (event-stream-args io))
            (ftype (filename-type (object-name io)))
            (autype nil)
            (fmat nil))
        (cond ((string-equal ftype "snd")
               (setf autype mus-next)
               (setf fmat mus-bshort))
              ((or (string-equal ftype "aiff")
                   (string-equal ftype "aif"))
               (setf autype mus-aifc)
               (setf fmat mus-bshort))
              ((string-equal ftype "wav")
               (setf autype mus-riff)
               (setf fmat mus-lshort)))
        (unless (getf inits ':header-type)
          (push autype inits)
          (push ':header-type inits))
        (unless (getf inits ':data-format)
          (push fmat inits)
          (push ':data-format inits))
        (setf (io-open io)
              (apply #'init-with-sound
                     ':output
                     (file-output-filename io)
                     :play
                     nil
                     inits))
        (when (audio-file-output-trace io)
          (apply #'tell-snd (file-output-filename io) inits))
        io)
      (call-next-method)))

(defmethod close-io ((io audio-file) &rest mode)
  (let ((wsd (io-open io)) (*clm-with-sound-depth* 1))
    *clm-with-sound-depth*
    (when (eq (slot-value io 'output-trace) t) (format t "Done!~&"))
    (when (and (consp mode) (car mode)) (setf (wsdat-play wsd) nil))
    (finish-with-sound wsd)
    (setf (io-open io) nil)))

(defun definstrument-hook (name args)
  (let* ((opts (if (consp name) (cdr name) (list)))
         (tpar (getf opts ':time-parameter)))
    (formals->defobject
     (list* (if (consp opts) (first name) name) args) tpar)))

(defparameter *definstrument-hook* (function definstrument-hook))
